<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SHA-1:大坨变小坨的神秘哈希算法]]></title>
    <url>%2F2018%2F10%2F24%2FSHA1%2F</url>
    <content type="text"><![CDATA[小韩同学上安全与认证课时听懵了，尤其是logical functions那块的操作，什么乱七八糟的玩意儿啊？？于是课后自己调研一下写一篇笔记。 本文参考了IETF RFC3174, FIPS PUB 180-4两篇官方文档，以及两个Youtube上的tutorials，credit见文末。 BACKGROUNDSHA is a abbreviation of Secure Hash Algorithm originally designed by NIST &amp; NSA in 1993, which was then revised in 1995 as SHA-1. It’s commonly used in applications related to Cryptography and Data Integrity in early years, and afterwards replaced by later versions (i.e. SHA-2 or SHA-3) due to security concerns. I/OInput: it takes binary input of any size. Output: it produces a message digest of 160-bit hash value (20-byte, or 40-digit in hex). HOWThe processing consists of: append padding bits append length MD buffter, where MD represents Message Digest process message in 512-bit blocks output: 160 bits PRE-PROCESSING Padding the Message The purpose of this padding is to ensure that the padded message is a multiple of 512 or 1024 bits, depending on the algorithm. –&gt;只有补位变成合适的长度才可以放进“容器”进行运算。 对于任意长度的明文，SHA1首先对其进行分组，使得每一组的长度为512位，然后对这些明文分组反复重复处理。对于最后一组明文，往往长度小于512位，所以我们要补齐到512位才能做运算。由于明文的最后64位要预留来记录总长度，所以对于剩下的部分（原文和长度位的中间部分），我们在最左边补一个1，其余位补0。上课的时候老师没说最后64位的问题，但看课件上的图在100…0之后还有一小段粉红色，其实就是那64位长度位。 Parsing the Message The message and its padding must be parsed into N 32-bit blocks. 对于每一份512-bit的明文，划分为16个子明文分组M[0…16]，每个子明文分组为32位。毕竟要用的是32位的寄存器嘛。 Setting the Initial Hash Value H(0) Before hash computation begins for each of the secure hash algorithms, the initial hash value, H(0), must be set. 因为哈希算法都是头尾相接的，上一轮的结果要参与下一轮的运算，然而在做第一轮运算时我们并没有previous results，因为定义初始变量组。 ALGORITHMS, PROCESSINGS Sub-block, Words 我们一共要进行80轮运算，意味着我们可能需要80组明文，而在一开始我们只分出了16组明文M[0…15]，所以我们在这一步要把16组明文扩充成80组。 在运算中我们使用5个变量a, b, c, d, e，都是由5个寄存器A,B,C,D,E,运算所得。 扩充过程如下：80组中的前16组直接用M[0…15]代替，后边第17到80组调用Wt函数计算。 1234567扩充过程for each chunk break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15 Extend the sixteen 32-bit words into eighty 32-bit words: for i from 16 to 79 w[i] = (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1 80 Steps using f1 to f4 生成好80组明文之后，我们就可以应用到后续的80次操作啦，这乱七八糟的运算过程真是让我不禁感谢伟大计算机…运算过程看得我眼花缭乱，所幸这种没有多大意义的过程压根不需要记住，连自己动手算一下都不用… 我上课的时候就非常懵逼，我不懂80个32位明文怎么放进5个32位寄存器啊？？？调研的时候才发现，那80个明文是为了80次运算准备的，每次运算A,B,C,D,E这一组寄存器依据算法只调用1个32位的明文。 Compute the intermediate, referring the first slide above. 做完80次运算之后，我们还要把结果和初始变量组（或者上一轮的结果）做“+”运算。 Final hash value 做完第三步之后，我们刚刚处理完第一个512-bit明文，我们还要继续处理接下来的N个512-bit明文，当最后一个512-bit明文处理完之后，就得到了最后5✖32位的结果。 WHY1.Every bit of hash code is a function of every bit of the input. 只有所有输入位都参与了运算，且所有输出位都由运算得出的情况下，才能实现任何改动都会导致不同输出。 2.It is unlikely that two messages chosen at random will have the same hash code. 3.It is infeasible to produce two different messages having the same message digest. 后两条就是保证collision resistance, preimage resistance and second preimage resistance。 Reference:How Does SHA-1 Work - Intro to Cryptographic Hash Functions and SHA-1sha1 tutorial how sha1 works secure hash algorithm tutorialIETF: US Secure Hash Algorithm 1 (SHA1)FEDERAL INFORMATION PROCESSING STANDARDS PUBLICATION: Secure Hash Standard (SHS) SHA1算法原理]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大四</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Impostor Syndrome and Self-doubt]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%B2%A1%E6%9C%89%E5%A4%9A%E5%A4%A7%E6%84%8F%E4%B9%89%E7%9A%84%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[Natalie Portman Harvard Speech on 5/27/2015 In her moving address, she paints a picture with broad brushstrokes from all stages of her life — her time as a teenage actress, her experiences as a mother, her own days at Harvard, and the highlights of her incredible career, from V For Vendetta to Black Swan. Natalie talks a lot about how she found a way to stay true to herself and how she pushed herself fearlessly forward in every new and challenging situation. “So I have to admitted that today, even 12 years after graduation I’m still insecure about my own worthiness and I have to remind myself today you’re here for a reason. “ “You are here for a reason. Sometimes your insecurities and inexperience may lead you, too, to embrace other people’s expectations, standards or values. But you can harness that inexperience to carve out your own path, one that is free of the burden of knowing how things are supposed to be, a path that is defined by its own particular set of reasons.” “Prizes serve as false idols everywhere. Prestige, wealth, fame, power, you will be exposed to many of them, if not all.” “So we bump up against the common troll I think of the commencement address people who achieved a lot telling you that the fruits of the achievement are not always to be trusted. But I think that contradiction can be reconciled and is in fact instructive. Achievement is wonderful if you know why you’re doing it. And when you don’t know, it can be a terrible trap.” “I realized that seriousness for seriousness’ sake was its own kind of trophy and a dubious one, a pose I sought to counter some half-imagined argument about who I was. There was a reason that I was an actor. I love what I do. And I saw from my peers and my mentors that it was not only an acceptable reason, it was the best reason.” “And it’s not about quantity. It’s about taking pleasure in the perfection and beauty of the particular. I’m still learning now that it’s about good and maybe never done, that the joy and work ethic and virtuosity we bring to the particular can impart a singular of enjoyment to those we give to and of course, to ourselves.” “I feel lucky that my first experience of releasing a film was initially such a disaster by all standards and measures. I learned early that my meaning had to be from the experience of making the film and possibility of connecting with individuals rather than the foremost trophies in my industry: financial and critical success. And also those initial reactions could be false predicators of your works’ ultimate legacy.” “You can never be the best, technically. Some will always have a higher jump or a more beautiful line. The only thing you can be the best at is developing your own self. “ “People told me that Black Swan was an artistic risk. A scary challenge to try to portray a professional ballet dancer. But it didn’t feel like courage or daring that drove me to it. I was so oblivious to my own limits that I did things I was woefully unprepared to do. And so the very inexperience that in college had made me feel insecure and made me want to play by other’s rules now is making me actually take risks I didn’t even realized were risks.” “Your inexperience is an asset, and will allow you to think in original and unconventional ways. Accept your lack of knowledge and use it as your asset.” “Each time you set out to do something new, your inexperience can either lead you down a path where you will confirm to someone else’s values or you can forge your own path even though you don’t realize that’s what you’re doing. If your reasons are your own, your path, even if it’s a strange and clumsy path, will be wholly yours. And you will control the rewards of what you do by making your internal life fulfilling.” Not having any clue what you’re doing can be a blessing in disguise. Inexperience can be as good as courage. Making time to do good works is worth it.]]></content>
      <categories>
        <category>Living</category>
      </categories>
      <tags>
        <tag>大四</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打好大三这一年的信息战[更新中...]]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%A4%A7%E5%9B%9B%E5%9B%9E%E5%BD%92%E6%96%87%2F</url>
    <content type="text"><![CDATA[老学姐对大三这一年的总结，文末附各学科资源（国院）。 Part 1: 保研/直博，都是“信息战”与“沟通牌”Part 2: 发论文不仅能保研加分，还能为申请提高软实力Part 3: 好好上课不仅会得高分，还意味着推荐信轻松到手Part 4: 幸存者偏差，别听某些中介瞎忽悠Part 5: Q&amp;As(海外毕设/QM直博/QM final year/美赛…etc) 臭LeanCloud，吞我评论吞我访问量，不知道开发者咋想的，counter应用老自动添加comment class导致和别的应用初始化冲突，以前我手动删了好几次，又不想丢失数据…最近发现可以绑定class，现在应该可以正常留言了。以及我这篇文章写的有点早了，但是等时机成熟了估摸着老学姐就忙别的去了，所以先写出来，慢慢补充，有任何问题欢迎留言或者联系我更新。 保研：学生与导师的双向选择 你该怎么赢想要完美地实现保研之梦，除了依靠过硬的自身条件，还需要有足够的信息和“情报”作为支撑。如果不了解意向院校的保研招收情况，缺少必要的导师信息，不能根据现实情况的变化实时调整自己的计划，那么结果很有可能就是一阵手忙脚乱之后败兴而归。所以，招生咨询和联系导师这个环节应当引起大家的充分重视。 选导师的渠道官方渠道：浏览学校各学院的官方网站，不仅能获得各导师的详细信息，还能及时知晓夏令营招生等活动的安排。如果对于该院系的招生信息仍存有疑惑，或者该院系最新政策未出，可以直接与负责研究生招生工作的老师和研究生导师联系，咨询最新的招生信息。 非官方渠道：就数据来看，北邮大部分学生倾向于本校保研，这就要请出传说中的北邮白名单了；往届师兄师姐的推荐：刚刚参加过夏令营、推免的前辈们手中都有大量的资源，同时对院校的最新情况也有较清晰的认识和记忆，所以及时取经是缩小信息差的关键。 联系导师的重要性联系老师主要是起到学生和老师相互了解的作用，对于童鞋们而言，联系老师能让老师提前了解你的情况，有机会争取到老师的口头offer； 同时通过和老师的交流还可以深入了解老师的情况（一般各学校院系的网站上对各老师的介绍都比较简单过时，很难了解到一些具体学术方向的情况），如果某些老师比较nice，还可以咨询到一些关于自己未来在专业上发展的建议。 什么时候开始联系老师这个问题比较随缘，联系太早了可能耽误自己时间还给别人白打工，联系晚了导师的名额可能已经分配完了。一般来说，建议保研大三下学期5~6月份就可以着手准备练习老师的事了，可以先做前期的调查，查阅各高校网站的导师信息、咨询你自己的学长学姐，选中一些候选的老师，然后可以开始联系了。直博的同学下文会讲到，越早越好，有意向了就赶紧联系（尤其是没publications的小菜）。 联系导师如何写邮件我个人觉得给导师发的邮件就相当于第一轮“筛选”了，毕竟导师会从这封邮件了解你的个人信息和背景情况，顺利得到老师的回复和面谈机会相当于你已经从第一轮“筛选”中得到青睐，脱颖而出，所以好好写邮件正文和优秀的个人简历是必须的。 老师不可能长时间不查看邮箱，所以长时间没收到邮件回复的你可能需要尽快另做打算，不过也存在特殊情况，比如说老师觉得选人为时过早，等到接近保研的日子才回复邮件通知你面试；或者老师特别忙，半个多月才有时间回复你。所以不要灰心，遇到不回复邮件自己又特别心仪的情况可以直接去实验室敲门，毕竟见面比邮件更有诚意（请带上C.V.）。 附两个邮件正文案例，邮件附件记得附上个人简历。更多详细案例见后文链接。 更多保研细节信息请参考以下几篇文章： https://mp.weixin.qq.com/s/sFEsCuzTy8FdB-9uCp8ahw https://mp.weixin.qq.com/s/x7hrtmLV-4_kzGLZElyevw https://mp.weixin.qq.com/s/aDTBwjt0QwDHxURsiBtfmw https://mp.weixin.qq.com/s/6-hUkQvOGVRGKgSFKY77HQ（邮件案例） https://mp.weixin.qq.com/s/r1P1aZ9m8_XV-0YUqnpOFA（论文期刊） 保研：想要保研的你，可能压根就没听说过如何直博一个误解：成绩好的学生都选择读研究生，成绩差才迫不得已直博了。 直博or读研究生，是个人选择问题，要看你想走学术研究这条路，还是想进企业走“打工务实”这条路；之所以存在那样的误解，其实原因是相对于导师的利益来讲，研究生能给他带来三年的“收益”，而博士生可以带来五年的“收益”，所以即使一名学生基本功相对来说弱一点，五年的时间也足够历练了，况且还能给导师多打两年工呢。 直博or保研没有好坏优劣之分，要看哪个更适合自己；相对来讲，直博意味着更长的发芽时间（国内通常是五年毕业），纵向的知识程度（在自己选择的方向上纵向延申，越深越透彻），更好的待遇（更多的奖学金，更好的住宿条件，更多的补贴），后期上升的地位和社会福利，而研究生意味着消耗较短的研习时间（通常三年毕业），横向的知识程度（实践的工程知识覆盖面比较广，横向发展），前期迅速的晋升期。 为什么直博的学生寥寥无几？不妨看看知乎上大家的讨论:为什么大多学生对直博敬而远之，而学校却“连哄带骗”要录取直博生？，除了文中的看法，还有一个关键的原因：大家根本不知道还能直博，或者说，不知道如何直博。 直博的过程和保研非常不一样，直博的名额确实非常少，所以你一旦决定了要直博，要迅速行动，因为”院里的直博总名额“一定小于”所有导师的直博名额总和“，比如说某学院有20位博导，每位博导一年有1个直博名额，那么这个院里所有博导的直博总名额就是20个，但是这整个院里的直博名额可能只有3个，照理说需要择优录取，但是以我的经验，最后很可能的结果就是先到先得，谁先拿到了前三个名额谁就能直博。 结合我自己的亲身经验，我在今年3月底选定了导师，确定要直博之后，4月初导师就帮我在教务报好直博名额了，等到5、6月的时候身边一个朋友也想直博，于是我帮他咨询了一下是否还能拿到我们院的直博名额，得到的结果是：晚了，排不上号了…这件事真的多亏了当时我遇到了一位懂流程的学长，帮我缩小了信息差，抢到了名额。 当然也存在某个院直博名额根本用不完的情况（木有人报，每个学校每个院情况不一致嘛）。 关于直博，最后再说一句：出国直博的情况和国内完全不一样，国外直博对学生的要求特别高，想要出国读博的学生一定要尽快多发paper。 论文：发论文的好处这么多，你还来得及吗？研究生毕竟是与研究相关，还是学术水平站最核心的地位，这时有几篇paper，自然是能把很多人抛在后面了 ，除了长脸，还能享受保研政策的加分，然而对于想要通过论文加分的同学，考虑到论文从写好到检索的周期很长，所以需要你在大三上学期完成发表，否则很有可能赶不上加分了。 而对出国的同学来讲，论文也可以提升自己的软实力，但是相对来讲没有那么着急，因为你只需要在申请的时候填入论文号，不需要等论文彻底发表出来。 一般要多长时间可以发表？不同的杂志出版周期不一样，一般要两三个月（特别快的一个月左右甚至半个月，一部分可以办理特别加急发表），杂志有个出版周期的问题，而且有的杂志版面很紧张，所以，如果用，应尽早预订，不宜临时抱佛脚，以免被动。每年三月份到十月份，是各地陆续上报职称材料的高峰期，各个正规杂志稿子都大量积压，版面都比较紧张，有的杂志可以安排的论文又很有限，因此应当及早准备。早准备，早受益，拖拉很有可能误事。 我发表论文有没有稿费给我?学术论文的发表需要作者自己出审稿费和版面费。很多作者还是懂得发表学术论文收取版面费的事实，但也有极少数作者似乎还没有分清楚学术期刊不同于娱乐杂志。学术期刊的存在，旨在向大家传播相对枯燥的学术研究成果，因此出版发行量较少。如果不适量收取版免费，是无法维持生存和发展的。 也就是说，你发论文，你要给人家钱，且篇幅越长给钱越多，比如多一页多给两百块。 刊物类别和级别都有哪些？ 从是不是核心期刊上区分，有核心期刊和非核心期刊，核心期刊目录是北大图书馆和北京高校图书馆期刊研究会编制的一个目录，列入这个目录的是核心期刊。 对于保研的同学尤其要注意查看学校的保研政策关于论文加分的这一项细则，可以看到我校规定EI和CPCI/ISTP享受同等加分，但是后者相比EI周期要短很多，相对也容易一些。 出国：我很忙，我要考GRE/GMAT/T/I，翘课有什么损失？大三这一年，我身边有很多同学为了考试疯狂翘课，最后期末周的时候痛苦预习，疯狂熬夜；做大作业的时候找代写，验收时忐忑祈祷别gg；但其实翘课带来的最大的损失不一定是悲伤复习周和GPA下降，尤其是对于成绩较优秀的同学来说，翘课面临的惩罚可能是机会的流失和不匹配自己实力的推荐信。 国院的学生在这一年会有两个比较重要的机会：Innovation Project和Winter Hack，Innovation Project就是传说中的英方大创，由英方的几位老师选定项目然后带着学生完成，这个项目大概率会成为自己的毕设，所以参加了这个项目，不仅意味着有了项目经验，提高申请软实力，还意味着毕设比别人进度提前，和老师关系混好了还有推荐信拿，甚至是老师帮你改PS… 这个英方大创要先自己递交申请，然后导师面试，如果你选中的项目导师恰好是你某一门课的授课教师，那么你的积极上课和前排刷脸一定会提高你被选中的几率…Winter Hack就是寒假飞去QM蹲实验室做项目，也是个不错的机会，毕竟自己只用掏饭钱，相当于免费伦敦游。 在推荐信这方面，推荐信分两种，一种是自己写的找老师签字，另一种是老师在线填写。QM的老师往年出现过黑推的情况，大概就是给一个学生写的推荐信内容是诸如“我并不是很了解这名学生…”此类的话，仔细想想如果你经常翘课，老师根本不认识你，对你也没有什么印象，给你写推荐信也不可能真的结合你自己的情况来赞美你啊；相反，如果你前排好好上课，积极互动，老师才会痛快地答应你，给你写真情实意的推荐信，你也不会到最后抓耳挠腮纠结怎么给老师发邮件介绍自己骗到推荐信，如果跟老师关系好了，连发邮件都免了，一条微信老师就把推荐信模板发给你了（当然这不是在怂恿你不按规矩来），最后提一句：外教记性真的特别好，以后你会有各种当面的机会跟他沟通推荐信事宜，也不用害怕他/她把你给忘了。 出国：大中介与小工作室，中介说我能上XX学校是真的嘛？大公司和小工作室有什么区别大中介诸如新东X、津X这类大型公司，留学中介服务都是标准流水线操作，接待你跟你聊合同的是一批人，给你写文书/改文书的又是另一批人，相对来说大公司资源更多一点（毕竟人多 科科），如果需要找实习或者发论文很可能提供“一条龙服务”；小工作室一般是留学归来的学长学姐们开的，可能一两个人负责了面谈/写改文书/找实习的全部服务，相对来说整个流程更了解你，更有人情味… 我觉得大小中介也没有好坏之分，想找到一个好中介最重要的可能是你多跑几家，多聊几家就知道各自的水准了…博主本人曾经遇到一个工作室，是几个G5回来的学长开的，学长们因为在英国呆过好多年了，从留学到工作到玩到住宿到历史，跟我从下午聊到天黑… 和那些大公司培训出来的接待员比就是不一样… 可惜我最后还是选择先留在国内了（捂脸）。 中介把你说的那么好 就是想让你早点签合同好中介不少，差中介更多。很多中介第一次面谈会把你聊得特别开心，让你迫不及待就想赶紧签合同…毕竟把你的期望调高，你越觉得自己能申上好学校，签约的可能性就越大；可是你要知道，你又不是光申一所学校，如果中介在给你规划的学校里随便中了任意一所（即使是比你水平低的），中介费也不会全退啊；签早了，不打算出国了，中介费也不退，所以中介当然让你越早签越好。就算你最后一个没中，中介费全退了，你的损失是失学了晚入学一年，中介的损失是什么呢？中介没有损失，毕竟又不是你一个人签了合同。 你可能会说不对啊，我看了中介往年的案例，跟我水平一样的学生真的申到了那个学校啊。嗯，幸存者偏差，你没看到的是那个人可能比你多了牛推，多了大牛的项目，中介一般只会展示申请人的GPA/(G)/语言成绩，这样光溜溜的才好让你相信你和他们一样能申到dream school。 所以我的建议是…GRE/GMAT/T/I起码考出来一样再签中介，那个时候你可能才确定要走出国这条路，才真的比较了解自己的target school。 在补一句：想去澳洲的同学真的不要找中介，澳洲学校通常会给推荐人好处费，国院往届墨大毕业的学姐就可以帮忙免费申，只需要1K5的保证金，等你确定入学了再退给你，相当靠谱。 Q&amp;As（问题收集中）今年美赛二奖还有加分吗？之前我们这届一直在传美赛二奖不再享受保研加分了，但是小伙伴之前咨询了教务处，16级美赛二奖依旧享受0.5分的保研加分。 QM直博什么流程，什么时候准备比较合适？众所周知QM每年都会有直博全奖名额，这个全奖指的是QM给免除全部的学费，并不包括生活费，想免除生活费需要走CSC项目，且近些年CSC申请的人越来越多，竞争越来越大。QM直博大概就是你选定一位导师，发邮件套磁之后和ta通络一番，等到正式申请的时候走个面试过程，然后你就被正式录取了，要说有什么要求，QM给的要求就是雅思6.5，至于老师收不收你就跟保研一样看你方向是否match，努不努力了…（不过你起码要QM成绩70以上吧）至于CSC项目，还需要雅思成绩/publications/research proposal这三样，学姐说北邮成绩88+比较稳妥。我觉得大三这一年英方课居多，可以通过这一年观察哪个导师适合自己，如果是没有paper的同学大三下学期或者暑假开始联系，越早联系越好，这样可以让老师督促着发paper增加CSC申请通过的几率；如果自身条件比较硬也不担心paper的话大四上9、10月联系正合适。 QM plus有相关导师资料和往年招收PhD的情况。 海外毕设海外毕设就是每年送出去一批优秀的学生去西班牙或者日本的学校做毕设，会有一位QM老师做第一导师，外校老师做第二导师，这个过程是自费的，不过优秀学生可以获得奖金。每年大三下学期会有相关讲座，介绍具体学校具体项目等信息，注意看邮件通知。讲座的时候老师也会强调…有心仪的项目，越早联系越好。虽然这个选拔过程看起来和Innovation Project差不多，但是越早联系老师，就能越早沟通具体项目方向和细节嘛，赢得老师芳心的可能性也就越高。 QM Final YearQM final year就是大四在QM念，课程体系相似但不是所有课程都完全匹配，且时间安排不太一样，比如：在QM那边大四的上学期没有期末考试，会统一到下学期考…申请过程大概就是：学校发通知——开讲座聊细节——开始填表申请——QM安排住宿——学校核对资格整个过程也是自费，从学费到住宿费到生活费，全部自费。按照成绩最高可以获得5000英镑的奖学金（刚好抵消住宿费诶）。因为去了QM肯定没法补考北邮这边的考试也不能参加北邮的创新实践类活动了，所以申请要求无挂科且创新学分已休满。 待补充…今天就先写到这里了。 大三资源汇总[Internet Protocols]链接：https://pan.baidu.com/s/1PerQRsvH3n5kfYwC5f8ddg 密码：qt5p [Telecoms System]链接：https://pan.baidu.com/s/1960dv2S_sJaJhSBlNdTTVw 密码：4xjf [Advanced Network Programming]链接：https://pan.baidu.com/s/1l2MVthVXR76zUh6fU56VTA 密码：r5qy [e-Commerce Law]链接：https://pan.baidu.com/s/1Kn6SCysfvWnHrNo4jkLCrw 密码：j6yj [Internet Applications]链接：https://pan.baidu.com/s/1fhYQnEBtD81K-c2Q26jxQw 密码：650s [Software Engineering]链接：https://pan.baidu.com/s/1yDqmnXU4oTFkmrQFlQQy_A 密码：wwg0]]></content>
      <categories>
        <category>Living</category>
      </categories>
      <tags>
        <tag>大四</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链踩水]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[第一次group meeting听学长们讲自己的作品，其他都大概能明白是什么意思，但是智能合约这个概念，我一点都不理解，遂积累一下学到的理论知识和概念。 智能合约(Smart Contracts)：CODE AS LAW 一个栗子：《老友记》中的智能合约当今社会，执行合约需要耗费大量社会资源。比方说，A、B两家公司签订合同，后来A违反合同条约，导致B损失重大。B想要拿回属于自己的东西，于是向法院起诉。就算B打官司赢了，判决书生效后，他还需要向法院申请强制执行，包括立案，提供财产线索……整个流程下来，每个参与人都很憔悴，尤其是本来就是受害方的B。 而智能合约能让这一切变得简单很多。智能合约和上述传统合约的区别，就在于“智能”，不涉及人类主观想法，一切皆代码。 智能合约，就是一段写在区块链上的代码，一旦某个事件触发合约中的条款，代码即自动执行。也就是说，满足条件就执行，管他愿不愿意。 在《老友记》中有一集，瑞秋、莫妮卡和钱徳、乔伊打赌，如果男人们能猜中购物袋里装着什么，就给他们10美元。后来他们猜中了，但瑞秋和莫妮卡却赖账。不管钱徳怎样去讨要，女人们就是不给。 这种情况下，钱徳和乔伊不可能去抢女生的钱包拿这100美元，只好认了。但如果有了智能合约，一旦男生们猜中，不管瑞秋和莫妮卡怎样耍赖，智能合约代码将自动执行，并把这10美元（真实的情况是数字货币）打到男生们的账户。 智能合约的工作原理：构建 → 存储 → 执行1）智能合约由区块链内的多个用户共同参与制定，可用于用户之间的任何交易行为。协议中明确了双方的权利和义务，开发人员将这些权利和义务以电子化的方式进行编程，代码中包含会触发合约自动执行的条件。比方说，你把一套闲置的房子租给A，那么，这份智能租约中就规定了A必须在每月5号之前给你打房租、你必须在收到房租时马上给对方钥匙等条款。 2）一旦编码完成，这份智能合约就被上传到区块链网络上，即全网验证节点都会接收到你和A的租房合约。 3）智能合约会定期检查是否存在相关事件和触发条件；满足条件的事件将会推送到待验证的队列中。假设A在4号提前打房租给你，这个事件就成了该合约的触发条件（每月5号以前）。 4）区块链上的验证节点先对该事件进行签名验证，以确保其有效性；等大多数验证节点对该事件达成共识后，智能合约将成功执行，并通知用户。 5）成功执行的合约将移出区块。而未执行的合约则继续等待下一轮处理，直至成功执行。 智能合约有什么用在区块链社会里，大家共同维护一个区块链账本，所有交易数据无法篡改、不可伪造，还能减少人工对账的出错概率和人力成本；随着智能合约普及，我们也会变得更加佛系。面对潜在的纠纷，无需自己出马，一切代码说了算。 乘飞机买延误险，理赔就变得简单多了。投保乘客信息、航班延误险和航班实时动态均以智能合约的形式存储在区块链上。一旦航班延符合赔付标准，赔偿款将自动划账到投保乘客账户，保单处理十分高效，你也不需要跟工作人员费口舌、争论计赔时间等问题。 假设你借了一大笔钱给亲戚，虽然打了白纸黑字的借条，但催款的时候，如果对方有一种坚持不要脸的精神，而你也没有撕破脸、或者把对方告上法庭的勇气，你就拿不回本属于自己的钱。智能合约也许是解决办法之一，当然前提是双方把借款金额、还款时间、对方绑定银行卡信息等打包进合约中。到了约定还款日，借款自动划到你的账户里。 基本上，智能合约就是基于密码学技术的数字化合同，是一种计算机程序，而不是传统的纸质合同。描述这两者差异的简单方法，就是将自动售货机（智能合约）与售货员（纸质合同） 。 智能合约的额外优点在于，可以进行多方合作，消除潜在的人为错误和腐败风险，并设定每个人都同意的公开透明的标准。 目前主流的智能合约开发和运行平台是以太坊，以太坊的飞速发展得益于它是第一个内置开发编程语言的区块链，对开发人员相当友好。 以太坊（Ethereum）是将比特币中的一些技术和概念运用于计算领域的一项创新。比特币被认为是一个系统，该系统维护了一个安全地记录了所有比特币账单的共享的账簿。以太坊利用了很多跟比特币类似的机制（比如区块链技术和 P2P 网络），来维护一个共享的计算平台，这个平台可以灵活且安全地运行用户想要的任何程序（当然也包括类似比特币的区块链程序）。 推荐阅读什么是智能合约]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistics and SCM 总结]]></title>
    <url>%2F2018%2F07%2F02%2FLogistics%20and%20SCM%2F</url>
    <content type="text"><![CDATA[诶，来纪念一把物流链，我自己总结的时候是所有topic都过了一遍，但在发表之前我把部分topic删掉了，因为我觉得…那几个topic没法出题…并不需要记下来… 斜线部分我觉得也不太重要… TOPIC 1 IntroductionTheory of SCM Companies seek to design business models that meet customer needs better than competitors. Success depends on the ability to Design, Make, and Deliver innovative, high quality, low cost products and services that customers demand. ​ SCM Supply chain management is the design and management of seamless, value-added processes across organisational boundaries to meet the real needs of the end customer. Logistics defined “…the part of the supply chain that plans, implements, and controls the efficient, effective flow and storage of goods, services, and related information from the point of origin to the point of consumption in order to meet customers’ requirements.” Third-party Logistics (3PL) 3PL service providers are companies who provide a range of logistics activities for their clients. E.g. distribution centres, warehouse facilities, manage the delivery of the products through their transport fleets or undertake value-adding services such as re-packing. 4PL™ 4PLs™ originated by Accenture (previously Anderson Consulting). Modern supply chain network is global and complicated, the capabilities to manage does not exist in any one Organisation. There’s a need for a specialist Organisation, to form a JV with the focal firm, use its knowledge of SCs and 3PLs to manage and integrate end-to-end supply chain. TOPIC 3 Information Technology in a Supply ChainThree types of technologies Product technologies – features and characters of a product/service Process technologies – method, procedures · Assembly line model · RFID, chipping Information technologies – collection, storage, sending of data · IoT · Big data Role of information in SC Information is a key driver that serves as the glue to create a coordinated supply chain. Information must be: · Accurate · Accessible in a timely manner · Be of the right kind -&gt; match Information provides the basis for some decisions · Inventory · Transportation · Facility The importance of information Real-time information regarding availability, delivery, shipping, and invoices allow for improved customer satisfaction. Substituting information for inventory or other resources reduces cost. Information can be used to increase flexibility. -&gt;chain shops Information sharing is redefining supply chain relationships. Enterprise Resource Planning – ERP ERP system – a single database surrounded by application programs that take data from the database and either conduct analysis or collect additional data for the firm. -&gt; integrated, single ERP implementation process \1. define the current process “as is” \2. define what the “best in class” business process should be \3. develop the system \4. work through all final “bugs” and then “flip the switch” ERP implementation issues Never-ending implementation Importance of process mapping Process redesign Use of consultant Excessive cost Resistance to change Error during implement Rapid technological change ERP- the future ERP systems were designed to enhance internal firm communication thereby facilitating exchange with external parties. Growing demand for collaboration among supply chain parties resulted in the proposal of two new systems: · ERP II · Enterprise Commerce Management - ECM Radio Frequency Technology \1. radio frequency transmissions between computer systems and mobile operators. · Used extensively in warehouse and distribution centre operations. · Improves picking efficiency and accuracy. \2. radio frequency identification tag (RFID) – code electronic chips embedded in the product or in product packaging. Comparison between RFID and bar code Unlike barcodes, RFID does not require line of sight to be scanned. RFID tags can hold much more information than bar codes. RFID information can be unique to every product, not just specific type of item or UPC code. · Used extensively in warehouse and distribution centre operations, which improves picking efficiency and accuracy. · Other benefits include: time-saving; easy to track; large volume of information gathered at the same time; · But barcodes are still in use, especially at POS (point of sales) level, due to its low-cost and compatibility with existing information system. The Supply Chain IT Framework The supply chain macro processes · Customer Relationship Management – CRM ​ The process that take place between an enterprise and its customers downstream in the supply chain. o Marketing o Selling o Order management o Call/service center · Internal Supply Chain Management – ISCM ​ Includes all processes involved in planning for and fulfilling a customer order. There must be strong integration between the ISCM and CRM macro process. o Strategic planning o Demand planning o Supply planning o Fulfilment planning o Field service · Supplier Relationship Management – SRM ​ The processes focused on the interaction between the enterprise and suppliers that are upstream in the supply chain. There is a natural fit between ISCM and SRM processes. o Design collaboration o Source o Negotiate o Buy o Supply collaboration · Plus: Transaction Management Foundation – TFM o Enterprise software systems – ERP o Earlier systems focused on automation of simple transactions and the creation of an integrated method of storing and viewing data across the enterprise o Real value of the TMF exists only if decision making is improved o The extent to which the TMF enables integration across the three macro processes determines its value Supply Chain IT in Practice Select an IT system that addresses the company’s key success factors Take incremental steps and measure value Align the level of sophistication with the need for sophistication Use IT system to support decision making, not to make decisions Think about the future TOPIC 4: Customer FulfilmentInformation-empowered customer – they are becoming more powerful · Customer are empowered with a broad range of product and pricing information · Channel power is shifting down the supply chain toward the end customer · Combined these phenomena have created customers that use market leverage to demand higher levels of services at lower cost. (product分三种：core, actual, augmented) Customer seek value in terms of \1. Quality · Quality includes both design and manufacturing elements · The product must be designed to live up to or exceed customer expectation · Manufacturing must then conform to the specification during production · Quality must be designed and built into the company’s products and processes \2. Cost - Four strategies are widely pursued: · 1. productivity enhancement – economy scale · 2. adoption of advanced process technology · 3. locating facilities in countries with low-cost inputs – factory, region · 4. sourcing from the world’s most efficient suppliers · \3. Flexibility – air ticket, refundable with higher price · Flexibility is the capability to adapt to new, different, or changing requirements · Flexible organisation operate with short lead time, are responsible to special customer request, and can adapt rapidly to unexpected events · Flexibility requires investment in information and automated production and logistics technologies. \4. Delivery · Competing on delivery means consistently delivering on-time and in the correct quality · Fast, reliable delivery requires the reduction of order cycle time and the elimination of variability · Coordinate sourcing, operations, and logistics \5. Innovation · Innovation creates new markets and changes industry standards · Early Supplier Involvement is a key element of innovation strategies Eight Dimensions of Quality \1. performance – the primary operation characteristics of the product \2. features – the bells and whistles or extras that distinguish a product from competitors’ offerings \3. reliability – the notion that a product can be counted on not to fail \4. conformance – measures how well a product matches established specifications \5. durability – refers to the product’s mean time between failures and its overall life expectancy \6. serviceability – the speed of repair when quality problems arise \7. aesthetics – perception of fit and finish or artistic value \8. perceived quality – overall perception of a product or brand’s quality reputation Example: if a car needs long-time charging – not enough reliability. You can build more chargers, improve serviceability Competing on the cost Four strategies are widely pursued: \1. productivity enhancement – economy scale \2. adoption of advanced process technology \3. locating facilities in countries with low-cost inputs – factory, region \4. sourcing from the world’s most efficient suppliers Customer Service Strategies · Traditional customer service focused on internal service levels and goals: o Percent defective products o Percent on-time delivery o Fill rate · Without feedback it is easy to emphasize activities the customer does not value. o Service Gaps Customer Satisfaction Customer satisfaction is based on whether a good or service meets or exceeds the customer’s prior expectations. The key to satisfying customer is to understand their needs so that unique products and services can be developed. Creating satisfaction should be the goal of the company’s culture and structure. Customer Success Strategies 非常简单，就是我要用我的好产品来让你更成功。并不是对end-customer来讲，而是对紧邻的下一级customer而言。 Customer success strategies use supply chain knowledge to help customers become more competitive. · A clearly communicated goal to help customers succeed · A clear understanding of downstream requirements · Investment in customer-valued capabilities · Training provided to customers · Resources shared with customer Example: intel – help you sell more products to end customers, since you use my components/chips. 三种customer fulfilment strategies · Customer service · Customer satisfaction · Customer success End Customer Where you can earn real money, from who really put money into the supply chain. Successful companies share information that helps the chain focus on the end customer. Customer Analysis · Customer analysis identifies customer needs, helping management to segment customer. · Customer segmentation – the identification of unique groups of customers who possess similar needs – allowing the development of products and systems necessary to fulfil the needs of different customer groups. · Who makes big/small difference to the supply chain, not age, gender, geographic location… Customer Segmentation with Pareto Relationship intensity can be categorized as follows: A - customers are valued and received the highest service B - customers should be managed carefully C – customers should be managed fairly and efficiently · A select number of A customers with Customer of Choice Relationships · Many A and most B customers with Highly Valued Relationships · C customers comprise Transaction Relationship WEEK 1 SEMINAR通过Beer Game让大家计算inventory和backlog, 前提是inventory存货花费1单位，backlog欠货则花费2单位，发现inventory和backlog之间的trade-off很困难，且欠货比存货要惨（欠货少赚2块钱，存货堆积花销1块钱）。 Bullwhip effect (exaggerated demands along the SC) 虽然不在正课里但是往年考过 Bullwhip effect cost can be as high as 12-25 %. Variation in demand is exaggerated as information moves upstream away from the point of use. Variation in demand is exaggerated due to infrequent demand and/or inventory level information exchanged and order batching. It can be effectively mitigated by: · Sharing point of sale data – focus on POS and VMI (vendor managed inventories) to reduce distortions. · Collaboration forecasting – allocate demand among customers based on past orders, not present orders · Collaborative future product promotion planning – work with vendors to create small order increments and reduce order batching, maintain stable price TOPIC 5 Order Fulfilment – Purchasing, Operations, and LogisticsDefinition Order fulfilment is the process that actually makes and delivers a product or service. Three functions are responsible: · Purchasing – acquires the inputs used to support production · Production – converts inputs into outputs that customers value · Logistics – transports and stores goods assuring access SCOR Model The Supply-Chain Operation Reference (SCOR) model helps to create a common vision for managing and coordinating five primary SC processes. Elements of the SCOR Model \1. Plan: processes that balance demand and supply to develop a course of action to meet sourcing, production, and delivery needs. This process aligns the supply chain with the financial plan. – purchasing, supply management, procurement(采购), acquisition of goods or service, sub substantially leverage profit. · Cut in cost is more effective than improving the sale. Example: labour and overhead costs are easy to cut… · 或者说 changes in purchasing spend have a significant leverage effect on a firm’s profits. · Outsourcing – purchasing role o Focus on core competencies has led many companies to outsource value added activities o Sourcing professionals take on the role of acquiring and managing: inputs, supplier capacity and supplier capabilites \2. Source: processes that purchase goods and services to meet planned or actual demand. Emphasis is on selecting suppliers, establishing policies. Scheduling deliveries, and assessing performance. \3. Make: processes that transform product to a finished product to meet demand. Emphasis is on scheduling production, measuring performance, managing inventory, and configuring the network. \4. Deliver: processes that provide finished goods or services to customer. Emphasis is on order management, warehouse management, and transportation management. \5. Return: processes associated with the return of products for any reason, and includes post-delivery customer support. Emphasis is on reverse logistic and long term customer support. Sourcing process -&gt;Recognition and Description of Need -&gt;Supplier Selection (identification-evaluation-approval-monitor) -&gt;Transaction Management – price · Reverse Auction: defined by suppliers bidding for a customer’s business. ​ Supplier participants should be prequalified, winning bidders should have their capabilities verified before contracts are issued. ​ Focus on price and competitiveness contrary to total cost of ownership and collaborative relationships. ​ Conditions (when to do): uncertainty of size, willingness of seller, large quantities, selling surplus assets, some services like car rentals, freight services, travel. -&gt;Transaction Management – orders · Purchase orders – specify the terms and conditions of purchase agreement and initiate supplier actions · Blanket orders – specify overall terms of agreement for a given time period and coven entire quantity to be purchased -&gt;Transaction Management – inspection · Supplier Certification Programs focus on improving suppliers’ abilities to produce high quality products, eliminate the need for inspection. -&gt;Transaction Management – payment -&gt;Performance Monitoring -&gt;Production Management The Logistics Process · Material management – is concerned with the inbound movement and storage of raw materials, purchased components, and subassemblies entering and flowing through the conversion process · Physical distribution- focuses on the outbound transportation and storage of finished products from point of manufacture to where customer wish to acquire them Order Cycle Order receipt-&gt;recognition of need-&gt;order preparation-&gt;order transmittal-&gt;order processing-&gt;order shipment-&gt;order receipt一个循环的圈 Order fulfilment activities · Inventory management · Facility location and design · Transportation management o Models include: Rail, Motor Carrier, Pipeline, Ship, Airplane, Internet · Warehousing · Order process Warehouse activities · Shipping and receiving goods and materials · Materials handling and order processing · Consolidating and distributing shipments · Transportation management · Products packaging and labelling · Re-packaging and mixing · Preparation of in-store displays · Light manufacturing or assembly · Scrap and disposal TOPIC 6 Supply Chain MappingMapping 是为了 improvement 主要有三方面： · Process mapping – create visibility of current and improved process. 就流程图，input – xxx process – output 描述整个过程。 · Value Stream mapping – depicts flow of information and material (physical)， 就是process map加上 process time, performance characteristics, information flow, physical flow这些流程之外的具体细节。 · SC mapping – displays dynamic that govern how a SC works, pipeline map How to improve? · Process analysis – identify the non-value added or redundant activities来砍掉没用的，提高效率；就是检查过程：总体的，个体的，循环的，最后在总体来一遍 o Exam the time, cost, resource and people involved in each step o Re-exam each decision symbol o Check each rework loop (iterative processes) o Finally look at each process step again · Supply Chain Design o Identify end customer o Determine value proposition就是价值观 o Analyse who possesses power (manufacturer, distributor, retailer or other party), 谁厉害我就让它当我的驱动力 o Isolate the major processes required to support the value proposition,主要流程肯定不能砍，只能先隔离出来 o Establish what the ideal SC would like, 就是看看优化完了能成什么样 · Design Tools o SCOR model – 5 activities o Supply Chain Double Helix o Nature of Product or Service o Product Life-Cycle · 怎么运用SCOR模型？ o Analyse the basis for competition o Configure the current supply chain as it is o Align performance levels, practices and systems across information and work flows o Implement SC processes 两种Supply Chain · Responsive – innovative products have relatively high profit margin, unpredictable short-lived demand, high risk of being obsolete, so supply chain should seek to minimize inventory and focus on speed and flexibility ​ Example: smart phones · Efficient – functional products have relatively predictable demand, long life cycle, large number of substitutes, so supply chain should seek to minimize cost and focus on reliable, high service level ​ Example: table TOPIC 7 Core Competencies and OutsourcingDefinition Core competency is the set of activities, skills or advantages that distinguishes a company from its competitors. · Value added 有价值 · Difficult to replicate or imitate 不好效仿 · Good at the skill set, willing to become excellent 是不是真的那么优秀 · Broad enough to enter diverse market or business 真的适用 Complementary Core Competencies 自己没有的，需要别人的 · Once a company finds its core competency, it can design SC to support its competitive strategy, value proposition and competency development 扬长 · Outsourcing non-critical activities to SC partners allow companies to leverage complementary core competency 避短，自己没有的就找外包伙伴来做 Outsourcing定义 Outsourcing is the process of moving an aspect of production, service or business function from within an organisation to an outside supplier. Outsourcing Trend · Contract Manufacturing – CM, a third-party makes an end product or major component under another’s company’s brand · Third-Party Logistics – 3PL, using a supplier to provide some combination of logistics activities · Off-shoring – outsourcing to a different country · Business Process Outsourcing – BPO outsourcing support functions such as HR, payroll, logistics OEM original equipment manufacturer A company that purchases computer or other complex components from manufacturers, add other hardware or software, and sell the system, for specific application Example: Dell buys chips from Intel and then sells Dell PCs EMS electronic manufacturing services Companies that test, manufacture, distribute and provide return/repair services for electronic components and assemblies for OEMs, also called electronic contract manufacturing ECM ODM original design manufacturer Company that designs and manufactures a product as specified and eventually rebranded by another firm for sale. It owns, designs in-house the products that are branded by the buying firm。 · ODM creates own intellectual property and proactive in patenting it. Benefit of Outsourcing By outsourcing non-strategic processes, an organisation can focus its attention on those things it does best to satisfy the customer. 有精力做自己擅长的 Other benefits include: - cost saving - capital conservation - performance improvement - access to low cost labor and resource - benefit from outside expertise Risks of Outsourcing · Strategic risk – long term, perhaps irreversible, risk based on a loss of knowledge relayed to core activities · Tactical risk – short term, based on used of supplier for capacity, not knowledge · Increased dependence on supplier for knowledge weakens the buyers relative bargaining power Supplier Relationships · Arm’s length 保持距离,适用于routine purchase · Niche – specialised providers · Hybrid – intermediate , cooperative · Full-Service – strategic, committed Buyer Skills Traditional buyers manage contractual relationships that are clearly defined, with clear expectation and performance measures. Outsourcing requires supply professional master creating and managing complex relationship due to the more fluid and less clearly defined supply environment WEEK 2 Class Exercise通过往上peanut butter的supply chain, 我们得到了一个总结： Supply chain mapping helps companies: · Improve strategic supply chain relations · Identify inefficiencies · Visualize process for communication · Analyse development of core competencies TOPIC 9 Cost Management· In business, retail, and accounting, a cost is the value of money that has been used up to produce something, and hence is not available for use anymore. · In economics, a cost is an alternative that is given up as a result of a decision. – 决策的代价 · In accounting, costs are the monetary value of expenditures for supplies, services, labour, products, equipment and other items purchased for use by a business or other accounting entity. – 记账时开销的数值 一个重要的结论：a % changes in cost cutting creates more than the profit of a 5% increase in sales Profit Leverage Effect · Measurable cost savings that don’t hurt sales have a tremendous impact on the bottom line. · Profit impact of cost reduction is much greater than the impact of increased sales. · The lower the average profit margin, the greater the impact. Strategic cost management uses cost management techniques to reduce the organisations costs and improve profit while supporting its value proposition. Three elements of strategic cost management: \1. Supply Chain Analysis \2. Value Proposition Analysis · Value proposition analysis is the essence of a corporation strategy, determining how an organisation chooses to compete in its markets. \3. Cost Driver Analysis Generic Cost Drivers · Level of outsourcing within a company. Companies that outsource may experience higher costs for additional services than if it had internal operations. Overall costs may be lower when demand is erratic. · Use of nonstandard materials, components and parts. Custom items are more costly because of low economies of scale. Custom parts may have better performance or lower operating costs. · Scale of operations. Very large manufacturing operations must have high stable volume. Small manufacturing operations may be unprofitable at high volumes due to overtime costs, inefficiency in operations, machine breakdowns and maintenance issues. · High level of finished goods product mix. The more options the organisation offers its customers, the more inventory it may have to carry, and the more flexible it production operations must be. Cost Management Tools · Cost analysis: including “should-cost” analysis or zero-based pricing, as well as analysis of service provider cost elements. · Price analysis: understanding the prices available in the competitive marketplace. · Total cost of ownership: analysing the true cost of acquisition, use, maintenance and disposal of a good, service, capital equipment, or process. · Target costing: determining what the market will bear and working backwards to see how much you can afford to produce the product or service for, and still make a profit Decision Classification Matrix a decision matrix can be used to determine the appropriate cost management tool The decision matrix classifies decisions according to: n · Nature of the Buy · Relationship with Supplier · Low Impact – low-cost commodity items; focus is on price analysis/comparison – Price Analysis Focus · Leverage – large purchases of items in competitive markets; focus is on cost analysis – Cost Analysis Focus · Strategic Item – large purchases from important suppliers; focus is on continuous improvement – Continuous Improvement Focus · Critical Projects – large dollar volume infrequent purchase; focus is on life cycle cost – Life-Cycle Cost Focus TCO Total Cost of Ownership – 不能光看acquisition cost（进货），要看整体流程的总成本 …includes all relevant costs, such as administration, follow-up, expediting, inbound transportation, inspection, and testing, rework, storage, warranty, service, downtime, customer returns, and lost sales. · Attempts to look at the big picture, considering cost beyond that of the purchase price. · a philosophy for understanding all relevant supply chain related costs of doing business with a particular supplier for a particular goods/service, or the cost of the process, e.g. supply chain design. TCO Analysis Steps Step 1: Identification of Benefits Sought -The first step in TCO analysis is to determine the benefits sought from the analysis. Step 2: Form a TCO Team Step 3: Identify Cost Drivers Step 4: Fine Tune - Step 4 allows for fine tuning of the TCO analysis including the use of sensitivity analysis. Step 5: Present - Step 5 requires that the TCO analysis findings be presented to the appropriate management level. TOPIC 10 Inventory Management – backlog or holding costDefinition Inventories are stocks of goods and materials that are maintained to satisfy normal demand patterns Why carry Inventory? · Provide product availability · Buffer production or acquisition costs · Buffer distribution costs · Hedge against inflation · Protect against uncertainty · Protect against unexpected events Inventory Management · Low inventory turnover = high inventory carrying costs, little (or no) stockout costs 存货堆积，存货成本高，欠货成本低 · High inventory turnover = low inventory carrying costs, high stockout costs 没有存货， 存货成本低，欠货成本高 · Managing the trade-off (product availability/responsiveness vs. cost/efficiency) is important to maintain service levels ABC Analysis – AGAIN! · CLASS A Can be controlled statistically. Good forecasting essential. Major stock control effort in this group. Safety stock usually employed, recalculated on frequent basis. Expert market knowledge desirable. · CLASS B Often controlled by computerised methods (materials requirements planning). Good forecasting desirable. Lean stock buffers. Manage by exception where possible · CLASS C Simple methods (two bin … ) may be used. Larger safety stocks allowed. Orders can be less frequent. Simple, often visual controls. Note: n Annual stock usage must be used, not current consumption Contemporary Approaches of IM · ABC Analysis · Just-in Time (JIT) Approach · Vendor-Managed Inventory (VMI) VMI employs the same principles as those of JIT inventory, however, the responsibilities of managing inventory is placed with the vendor · Inventory Tracking Vendor-Managed Replenishment · Suppliers actively manage inventory for customers. · Vendor monitors the buyer’s inventory levels (physically or via electronic messaging), makes periodic resupply decisions regarding order quantities, shipping, and timing. · Transactions customarily initiated by the buyer (such as purchase orders) are initiated by the supplier. · Benefits for suppliers - improved demand information; improved ability to allocate productive resources · Benefits for customers - Lower labour and inventory costs; Improved item availability; Improved responsiveness TOPIC 11 Safety Inventory - Managing UncertaintiesRole of Safety Inventory · Forecasts are rarely completely accurate · If average demand is 1000 units per week, then half the time actual demand will be greater than 1000, and half the time actual demand will be less than 1000; what happens when actual demand is greater than 1000? · If you kept only enough inventory in stock to satisfy average demand, half the time you would run out · Safety inventory: Inventory carried for the purpose of satisfying demand that exceeds the amount forecasted in a given period · Safety inventory is carried because product demand and lead time are uncertain and a product shortage may result if actual demand during lead time exceeds the forecast amount. Average inventory is therefore cycle inventory plus safety inventory · it tends to have a negative impact on supply chain cost but a positive impact on supply chain responsiveness/availability There is a fundamental trade-off:  · Raising the level of safety inventory provides higher levels of product availability and customer service  多备货 availability和customer service得到保障 · Raising the level of safety inventory also raises the level of average inventory and therefore increases holding costs 但多备货也会导致holding cost增高 Level of Safety Inventory · Measuring demand uncertainty o Higher levels of uncertainty require higher levels of safety inventory given a particular desired level of product availability o Higher levels of desired product availability require higher levels of safety inventory given a particular level of uncertainty o Demand has a systematic component and a random component o The estimate of the random component is the measure of demand uncertainty · Measuring product availability o Product availability: a firm’s ability to fill a customer’s order out of available inventory o Stockout/backlog: a customer order arrives when product is not available · Replenishment policies · Evaluating cycle service level and fill rate · Evaluating safety level given desired cycle service level or fill rate · Impact of required product availability and uncertainty on safety inventory Replenishment Policies Replenishment policy: decisions regarding when to reorder and how much to reorder · Continuous review: inventory is continuously monitored and an order of size Q is placed when the inventory level reaches the reorder point ROP · Periodic review: inventory is checked at regular (periodic) intervals and an order is placed to raise the inventory to a specified threshold (the “order-up-to” level) WEEK 3 SEMINAR大概的问题是discount is only for short term, overall profit is down… Distributors有了折扣了以后，想在折扣时多进货，结果导致库存积压，warehousing cost is even higher than discount Trade Promotion · Forward buying: customers move up future purchases to the present. 促销时预购 · Trade promotion lead to significant increase in lot size and cycle inventory because of forward buying by the retailer. This generally results in reduced supply chain profits unless the trade promotion reduces demand fluctuation. 促销时囤货 Objectives of the Manufacturer 厂家为什么要促销呢？ · Induce retailers to use price discounts, displays, or advertising to spur sales. 抛货 · Shift inventory from the manufacturer to the retailer and the customer. 清仓 · Defend a brand against competition. 跟对手打价格战 Reaction of the retailer \1. Pass through some or all of the promotion to customers to spur sales. 让利给消费者，以便抛货 \2. Pass through very little of the promotion to customers but purchase in greater quantity during the promotion period to exploit the temporary reduction in price. 并不给消费者让利，只是自己趁着折扣搞点囤货 -&gt;很可能出现堆积的问题 思考 · Faced with a short-term discount, it is optimal to pass through only a fraction of the discount to the customer, keeping the rest for themselves. 让利消费者一部分比较好 · Simultaneous, it is optimal for the retailers to increase the purchase lot size and forward buying for future periods. Thus, trade promotions often lead to an increase of cycle inventory in a supply chain without a significant increase in customer demand. 虽然消费者需求没涨，但自己为了多赚差价提前预购，囤货 TOPIC 13 Performance MeasurementRole of Performance Measurement · When performance is measured, performance improves. · Measurement Creates Understanding · Measurement Drives Behaviour · Measurement Leads to Results Traditional Measurement Areas that are essential to measure to accomplish customer service and profitability goals: · Asset Management o Return on Assets o Return on Investment · Cost · Customer Service · Productivity o Productivity is the ratio of total output to total input. · Quality o Measures of quality track the functionality or reliability of a product or service. o Six Sigma targets a quality level which achieves defect rates of less than 3.4 ppm Contemporary Supply Chain Measures Measurements consistent with supply chain management core principles emphasise: · Goal alignment o Supply chain managers must align key measures within their own organisation as well as within the supply chain · Customer satisfaction o customer expectation or satisfaction levels · Process integration · Total costs o Total supply chain costs are the sum of all costs incurred in planning, designing, sourcing, making, and delivering a product from raw materials to the final customer. · Inter-organisational collaboration Benchmarking The formal process of comparing the attributes of one organisation to those of another. Process consists of: \1. Define attribute to be benchmarked and identified a best-in-class comparison company. 要比较什么，和谁比 \2. Document the best-in-class process at strategic and operational levels. Compare with current practice specifying any and all differences. 比出来的结果是什么 \3. Develop a strategy, complete with specific methods, for adopting best practices. 如何提高 Benchmarking - Types · Competitive Benchmarking – evaluating best practices of leading competitors within industry. 和竞争对手比 · Non-competitive Benchmarking – evaluating best practices regardless of industry. · Internal Benchmarking - large global firms may find opportunities to disseminate best practices within the organisation. 和自己比 TOPIC 15 Law and Ethics in SCMFour Types of Warranties · Express warranty 说清楚 · Implied warranty of merchantability – fully merchantable 可售性 · Implied warranty of fitness for a particular purpose 有用，达到用途价值 · Warranty of title 名副其实 Ethics in Supply Chains It would be hypocritical to claim to be a ethical firm if it turned a blind to unethical practices by suppliers in the supply chain. In particular: · The use of child labour and forced labour · Production in sweatshops · Violation of the basic rights of workers · Ignoring of health, safety and environmental standards 例子：Foxconn 如何解决？Apple 要求Foxconn签订ethical agreement on contract Sustainable supply chain management requires that sustainability criteria be met while maintaining competitiveness through meeting customer needs. TOPIC 16 Relationship Management特别重要，不可能不考 第二次出现classification matrix了 主要的两种relationships 一、Transactional Relationships – should seek to satisfy two objectives 就俩目标 · 1. Maximum efficiency and handling transactions. · 2. Good relations, both parties feel they are treated fairly. · Focus is on cost o Use of reverse auctions o Managed for efficiency o Global sourcing · Relationships are often transitory o Receive minimal managerial time o Receive minimal assistance o Receive minimal investment · Outcomes o Lower administrative costs o Lower product and/or service costs o Better quality, innovation, and responsiveness o Enhanced technical support 一般刚开始大家都是比较冷漠的Transactional，后来如果我发现我可以信任你，你可以成为我的伙伴，那么我们的关系就shifting to alliance 二、Strategic Alliance · Focus is on coordinating complementary core competencies · Relationships are closely scrutinised and carefully managed · Intensive and open communication supported by linked information systems · Cross-organisational teams drive cooperative planning · Long-term relationships · Factors o Relationship represents a high-value and volume, either in sales or purchases. o SC member represents a large share of the company’s business, either sales or purchases. o Potential partner possesses skills, technology, or another unique aspect that cannot be found elsewhere. o Strategic component, service, or upstream/downstream relationship is affected. o Potential scarcity governs the marketplace o Intensive collaboration can create advantage: better quality, lower costs, shorter cycles, or unique service. Supply Chain Relationship Practices 背5个就行 · Personal contact - Personal relationships generate goodwill and reduce miscommunication · Clear specifications - Product, process and contract fulfillment specifications should be clearly stated to reduce confusion and ambiguity · Timely payment - Suppliers should be paid as quickly and easily as possible · Equitable treatment - Policies should be applied equally; playing favorites creates suspicion and mistrust, damaging relations. · Training – Appropriate support and training provided to customers and suppliers. · Open communication - Timely information shared via electronic linkages and face-to-face communication is critical Strategic Alliance - Benefits · Focus on individual strengths, potentially leveraging them into core competencies · Manage the chain as a value system, optimising resource usage across the chain · Offer unique product/service packages and one-of-a-kind satisfaction opportunities · Increase flexibility while spreading risk · Learn from SC partners Strategic Alliance – Customer Outcomes Lower cost Improved product quality Enhanced responsiveness Decreased order fulfillment times Innovation Improved allocation of scarce resources Strategic Alliance – Supplier Outcomes Long-term, large volume contracts Production stability Lower costs Keys to Successful Alliances Collaborative/joint efforts n Patience and perseverance n Collaborative continuous improvement n Personal relationships n Collaborative creativity and idea generation n Shared vision and objectives n Cultural fit n Trust n Mutual commitment to the relationship n Understanding of each other’s businesses n Mutual dependence n Willingness to be flexible and tailor services The Role of Trust and Power Trust is the foundation of SCM Promotes collaboration, risk taking, information sharing, and shared sources Real trust exists only when both parties agree that it does Negotiation Philosophies · Win-Lose Philosophy Fixed value exists in the relationship Goal is to capture as much about you as possible Pits customer and supplier against each other · Win-Win Philosophy – both must want win-win, and for longer-term Synergistic creation of value Working together both parties can improve their competitive position and profitability]]></content>
      <categories>
        <category>Living</category>
      </categories>
      <tags>
        <tag>大三</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Information Security and Privacy Law]]></title>
    <url>%2F2018%2F06%2F29%2FInformation%20Security%20and%20Privacy%20Law%2F</url>
    <content type="text"><![CDATA[法律作为电商交叉学科的第二专业，还挺艰辛的，毕竟要手写十几张纯英文的case analysis…我一直习惯在纸上写笔记写总结，然而当经历了三小时一刻的知识产权法之后，用了一整管钢笔水，我的手都要废了，眼镜要瞎了，无奈第二天还有一门Information Security and Privacy Law我已经放弃手写了，转手敲电子版，顺便把资料整理一下放到博客上。 以下资料根据王一安学姐的讲解以及课件整理。 总结Information: information extracts from data -&gt; valuable and meaningfulInformation Security concerns everyone.Privacy: an individual’s right to control the use and disclosure of their own personal information.(control of personal data, where control is the ability to specify the collection, use, and sharing of their data.)Personal information should be private, not publicly available.Information Security is the process used to keep data private.Security is the process, privacy is the result. Scope of Information Security (the processes, procedures and infrastructure) to preserve:- confidentiality含义? Only people with right permission can access and use information, protecting it from unauthorised access如何保证? Encryption, access control否则,后果? Identity theft, threats to public safety - integrity含义? Information systems and their data are accurate, predictable when processing, remain the same when not processing, accuracy and completeness如何保证? Controls ensuring the correct entry of information, authorization, antivirus那些情况会造成? Intentional employee or external attacks, accidental employee error - availability含义? Make sure information system is reliable, accessible when people with proper permission want to如何保证? Recovery plan, backup systems那些情况会造成? Intentional DoS attack, accidental outage Information Security LawsUS - Gramm-Leach-Bliley Act, regulates consumer financial information Payment Card Industry Standards, regulates credit card informationEU - General Data Protection Regulation (GDPR), regulates privacy and data protectionChina - Cyber Security Law, regulates privacy and data protection 重要概念Authentication, specific measure to integrity and confidentiality considerations; ensure that a machine or person is that which they purport to be.实现方法: digital signature, electronic PKI, multi-words password, block chain for cryptocurrency Risk Management, as means to justify information security laws, process of listing the risks that on organization faces and taking steps to control them.- vulnerabilitiesWeakness or flaw in the information system that can be exploited.(people, process, facility, technology) - threatsAnything that can cause harm – successful exploits of vulnerabilitiesAnything that has the potential to cause harm要会找出Source of threat, threat - risksA likelihood that a threat will exploit a vulnerability and cause harm, with information security impact, maybe high, medium, low - safeguardsSafeguard reduces the harm posed by vulnerabilities or threats, a measure to eliminating or reduce risk of harm • Administrative Safeguards– Actions, policies and procedures to prevent, detect, contain and correct information security violations– The largest part of the Rule is the management process具体： Security Management Process Assigned Security Responsibility Workforce Security Information Access Management Security Awareness and Training Security Incident Procedures Contingency Plan Evaluation Business Associate Contracts and Arrangements • Physical Safeguards– Controls to protect physical resources具体 Facility Access Controls Workstation Use Workstation Security Device and Media Controls • Technical Safeguards– Controls applied in the hardware and software on an information system具体： Access Controls Audit Controls Integrity Person or Entity Authentication Transmission Security Concerns哪些会造成事故 - Shoulder surfing, social engineering- SPAM with the capacity to deliver range of malware- Spyware and keystroke loggers (3,7 million South Carolina tax records)- Worms, virus, Trojans- Creation of ‘bot nets’- Logic bombs, backdoors- Phishing/Spear Phishing/Whaling- DoS/DDoS How can you meet the legal requirements, therefore? -&gt;Reasonable, appropriate, adequate security Source of Laws• Laws – rules – regulations• Common law – body of law that developed through legal tradition and court cases (case law/judge-made law) – impact on torts, contract, and property law 习惯法，来自于案例• Statutory law – written law that is adopted by the governments 成文法• Rules – governments delegate power to agencies to create rules, enforce rules, and review rules• Regulations – regulatory authorities have the power to create and enforce regulations – Privacy• EU Data Protection Directive (article 17)• US Gramm-Leach-Bliley (financial information privacy) and• US Health Insurance Portability and Accountability Act (health information privacy) The US Health Insurance Portability and Accountability Act (HIPAA) electronic protected health information (ePHI). • Laws about Telecommunications networks/services– EU Electronic Communications Privacy Directive (e-Privacy Directive)– Electronic Communications Framework Directive– US Telecommunications Act • Federal Communications Commission presumes that there is inadequate security where customer proprietary network information (CPNI) is breached. • Corporate Governance Laws– Financial transparency and securities market reporting and audit obligations– US Sarbanes Oxley Act (SOX) China• Cyber Security Law (effective from 1 June 2017) 没有关于时间的规定 Tort Law • A tort, in common law jurisdictions, is a civil wrong that unfairly causes someone else to suffer loss or harm resulting in legal liability for the person who commits the tortious act• Information security – duty of care to secure information• Action or lack of action that causes harm = liability 总结流程\1. defendant 有没有duty of care?\2. 有没有breach of duty?\3. show harm.然后就conduct successful tort lawsuit了 Contract Law• A contract is an agreement, giving rise to obligations, which are enforced or recognised by law• Information security – contractual obligation to secure information• Failure to secure information = liability总结：签订了Contract就代表形成了special relationship， 存在关于数据保护的agreement，如果没有效实现obligations，那么就liable 一个问题What is a data breach?答案：lose the control of data, no longer access the control of the information 要背的法： 美国的：US Health Insurance Portability and Accountability Act (HIPAA)• Privacy rule: privacy standards, including who can have access to protected health information (PHI) (all forms)• Security Rule: controls for ensuring access only to those who should have it (electronic information only)• Health Insurance Portability and Accountability Act 1996• The required implementation specification at § 164.308(a)(1)(ii)(A), for Risk Analysis, requires a covered entity to, “[c]onduct an accurate and thorough assessment of the potential risks and vulnerabilities to the confidentiality, integrity, and availability of electronic protected health information held by the covered entity.”• The required implementation specification at § 164.308(a)(1)(ii)(B), for Risk Management, requires a covered entity to “[i]mplement security measures sufficient to reduce risks and vulnerabilities to a reasonable and appropriate level to comply with § 164.306(a) [(the General Requirements of the Security Rule)].”• Personal health information is considered very sensitive o Confidential medical records o Public embarrassment, discrimination o Medical identity theft• HIPAA protects privacy and security of personal health information• Scope: Privacy and Security rules apply to covered entities and determine how they may create, store, use or disclose protected health information (PHI)• PHI is any individually identifiable information about the health of the person, including past, present or future mental or physical health information• Covered entities are those that handle PHI in a certain way – health plans, health care providers, health insurance companies, etc.要背的：Covered Entity must“implement policies and procedures to prevent, detect, contain and correct security violations.”我他妈觉得所有的法都在说这条啊 国际的： ISO/IEC 27001:2005 Information Security Management Systems– Requirements (有哪些duty)Information Security Management System (ISMS)• Risk-based approach• Reviews the processes that management teams must consider operating, monitor, review, and maintain IT systems• Specification for an Information Security Management System (ISMS)• Way to measure, monitor and control security management from a top down perspective• Details how to apply ISO/IEC 27002• This is the part currently certified• Part 2 defines a six-step ‘process’, essentially:• Define a security policy• Define the scope of the ISMS• Undertake a risk assessment• Manage the risk• Select control objectives and controls to be implemented• Prepare a statement of applicability• PDCA plan, do, check, act 国际的：ISO/IEC 27002:2005 Code of Practice for Information Security Management Set of security controls: the measures and safeguards for potential implementation• Control Objectives– General statements of security goals for each domain• Controls– Specific means to implement control objectives 中国的China Consumer Law Principles:– Enhanced penalties for consumer rights violations– Public interest litigation to remedy harms– Vendors have burden of proof– Unauthorized disclosures of consumer PI banned; required to be kept strictly confidential– Requires vendors/businesses to establish appropriate technical measures to safeguard information China Consumer Rights Law (2014)(personal information of consumers) requirements:- State the purpose, method, scope, and rules of collection of personal information of consumers;- Keep personal information of consumers confidential and not disclose, sell, or illegally provide this to others;- Have mechanisms in place to ensure the security of information collected; andNot send unsolicited communications to consumers 中国的Cyber Security Law (effective from 1 June 2017)– Provides for supervisory jurisdiction over cyberspace, defines security obligations for network operators and enhances the protection over personal information– It also establishes a regulation regime in respect of critical information infrastructure and imposes data localization requirements for certain industries 中国的Corporate Governance LawPRC Basic Standard for Enterprise Internal Control (aka ‘C SOX’) (2009)– Regulation requiring the establishment of internal controls and self-audits with annual reporting– Mandatory for listed companies– Build internal control strategies around the five ‘COSO’ control elements• Five key components of internal control:– Control environment– Risk assessment– Control activities– Information and communication– Monitoring 为什么云计算could computing是个大问题？Data is not stored on company’s own physical infrastructureLoss of control of data, lessen securityLoss of privacy of dataDependency on a third party for critical infrastructurePotential security and technological defects in the cloud’s provider infrastructureNo control over third parties contractually connected with the provider总结：– Cloud computing presents many benefits, but also new challenges– Lack of transparency, dependency, loss of control– Cloud computing governed by contract– Data and infrastructure localization Risk Analysis Process\1. Identify the scope of the analysis.\2. Gather data.\3. Identify and document potential threats and vulnerabilities.\4. Assess current security measures.\5. Determine the likelihood of threat occurrence.\6. Determine the potential impact of threat occurrence.\7. Determine the level of risk. Risk Management Process\1. Develop and implement a risk management plan.\2. Implement security measures.\3. Evaluate and maintain security measures. 前两周的例题： 有个online retail company跟顾客说我们有privacy policy来保证data secure，结果顾客发现data并不secure，问这个公司有什么legal duty？还是运用CLEO模型Claim, issue: 肯定是legal duty of information security啊Law: Consumer Law, Cybersecurity Law, Tort Law, Contract Law, Corporate Governance Law - C SOXEvaluation: xx法说要有责任干嘛干嘛Outcomes: 所以xx公司必须干嘛干嘛 —————————————-前两周到此为止———————————————-Privacy:Privacy is the interest that individuals have in sustaining a ‘personal space’, free from interference by other people and organizations - “The Right to be Let Alone” ——————–以下内容由刘家铭和祁星群两位同学总结——————- 有问题的地方我用删除线标记了，请无视。 Week 3：（更多注重在个人隐私保护）Privacy：指个人隐私Data protection：（Information）指对数据的保护，要大于个人隐私。 Privacy：来源于一个拉丁词。（想和你分离） Data Protection： 4个主要的模型：\1. EU GDPR：专门立法 综合法\2. Sectoral Law：中国立法 部门法\3. Self-Regulation：行业自律\4. Technologies：可以通过科技的手段保护，数字签名。 EUDPD：很重要！！！ 现在换成GDPR了 Sectoral protectionSpecific laws：部门法，类似于中国，多个法律共同保护Omnibus Data Protection：综合法，这些规定合到一起，组成了一部法律。香港和欧洲。 Data Protection in the EU：其中一个重要的点：Article 8, Council of Europe Convention on Human Rights and Fundamental Freedoms: Right to respect for private life 类似于宪法，高于众多的法律。告诉你有必要去尊重每个人的隐私生活。 EU DP law的一些关键词汇（需要记忆）  Defined in GDPR Article 4在GDPR的第四条中做出的明确定义：– Data Subject：指你，指你生成的数据– Personal Data– Processing：处理信息的过程，包括传递和存– Sensitive Data：敏感信息，在乎的信息– Data Controller：控制数据的人– Data Processor：处理数据的人，例如微博。EU: very high standards of DP：在DP管辖的EU，隐私保护很好， **这个是唯一需要记忆的法条：GDPR Article 45– “A transfer of personal data to a third country or an international organization may take place where the Commission has decided that [it] ensures and adequate level of protection.” 向第三国或国际组织转让个人资料，可在委员会决定[其]确保充分保护的情况下进行。EU向中国传递数据时，必须要确定第三方是否有资格保护我的数据。 46条：转的时候需要提供以下保证（这三点也需要背，必须！！！！）“appropriate safeguards”需要确定第三方有合适的保护机制。Enforceable data subject rights available 可强制执行的数据主体权利。Effective legal remedies for data subjects available 对数据主体的有效法律补救 What is ‘adequate’ protection? 什么是足够的保护？Nature of the Data：数据类型有所谓，健康类的sentitive应该保护Purpose and duration：数据的目的以上两点理解就OK！ 2002：EU Electronic Communications Privacy Directive这个要写全称。Cookies：必须要Opt in，用户必须确定consent。就是登录邮箱后会提醒是否记住密码，这个需要用户同意。Traffic data：data retention. 到底能存多久E-mail：发垃圾邮件，必须要人家同意 Cookies：notice and opt in，和之前的一样。Spam Email: “soft opt-out” 网站必须要有可以关闭的按钮 （答题时：不要说根据某个具体的法条，直接说**according to EU GDPR**和 e-Communications Privacy 这个两个法律就**ok**！！） Search Engines：之前没有出题 Week 4： 只看中国大陆，不看香港。 China：部门法国家 HK：综合法国家 Protection Minors Law：未成年人保护法，指18岁以下。第四条尊重了“personal dignity”（个人尊严）（考试答题：中国的Protection Minors对其“personal dignity”进行保护，他是未满18岁的，所以受保护）学有余力：“No organisation or individual may disclose the personal secrets of minors”，任何公司不得泄露你的个人信息。第31条：父母有权读未成年人的邮件Cybersecurity law:**不需要记忆，答题时需要写：2017年颁布了最新的Cybersecurity Law，这个法律出台了很多新的原则，关于providers的。这个法律规范了这些行为，让他们必须更注意用户隐私。就OK！ Chinese Criminal Law**：中国刑法：不允许卖信息，会处以三年一下的监禁。刑法，不允许监听。Constitution of China**：中国宪法**The freedom and privacy of correspondence：只需要记住一点，尊重通信自由！！！Anti-Spam Provisions：对垃圾邮件做出限制。只有你同意才可以给你发广告邮件，否则就不行。Opt-in consent to receiving advertising email （考试的时候只需要跟在一大堆法律的后面就OK，直接写同时中国也对垃圾啊邮件做出了限制，Opt-in consent to receiving advertising email） Regulations 2012：需要有user consent在收集信息，只能收集你需要的信息，不能瞎收集。用户的同意不能被mislead。 Regulation 2013：和2012的区别是规定了sensitive personal information，然后需要informed consent。 Data Breaches：如果data被别人获取的话，需要在15天内给予通知 Regulation 2014：罚款涨到了5万。 Regulation 2015：增加了对消费者的关注 Cybersecurity Law: 如果你做了Transfer of “personal information” outside of China这种行为，需要参照这部法律。还需要记忆：实名制。Real identity Civil Law：民法，不需要记忆。理解关于公民的名誉权 Tort Law：第36条规定了第三方的责任 答题模板类型一：案例题，给一个公司的情况，问你它的隐私保护做的怎么样？Or 给你一个法律有没有comply**隐私保护？（Week 1的内容，其实就是考你risk assessment）** （Week 1 第2个ppt，全的版本在第8个ppt，背不下来第八个就背简洁的2就行） 1.Threats：分为三类：physical，technical，people 2.Vulnerability 3.Risk 4.Safeguard（measures），可以是很具体的 5.怎么做（comply）？ 1.看是哪一方面的，给出具体的法律 中国：CSOX（简称，具体内容，5 internal control）， tort， criminal， regulations，consumer ，cyber security law 美国：SOX，Gramm-Leach-Bliley, HIPPA 欧洲：EU data protection directive, GDPR 2.具体的standard：HIPPA &amp;OSI 27002 3.3个特征，integrity，confidentiality，availability（对应每个词分析） ​ 4.measure：preventative，detective，reactive或者是physical，technical，people ​ 5.答：过程process OSI27001 PDCA （PDD） 6.没做到：criminal penalty. （关于楼上的standard和law，一般包括2类内容：1.duty 2.怎么做Implementation Specification） 类型二：问HIPPA or OSI 27002,27001**，CSOX或者是比较，或者隐晦的问你standard（类型一的一个具体变形比较难，需要背诵）** 背：HIPPA administrative，technical，physical OSI17799 10 domain OSI27001 PDCA CSOX的5个 类型三：案例分析题，谁谁谁在网上买了书，干了啥，等等。考你中国的各种regulations**或者考EU DPD**？EU GDPR 简易版的答题思路： 1.整理案例：按照每个人，分别做了什么来整理 2.根据每一件事件来列法条分析，一般包括： 中国：1. Minor no reveal minor protection +cybersecurity​ 2.E-mail：1.opt-in ads 2.anti-spam measures for E-mail service​ 3.collet information：user consent （no misleading） Regulation 2012​ Express consent（sensitive）​ Delete 用完就删 Regulation 2013​ Consumer Regulation 2015​ 4.breach（黑客）：report in 15 Regulation2013​ 5. Transfer： Cybersecurity​ 6.Penalty：1-3万 Regulation2013​ 5万 Regulation2014 还可以补充的中国法律：1.宪法constitutional law 2.civil law 3.criminal law 4.tort law 5.CSOX \1. EU：1. Human right 要求保护private right （GDPR+ePrivacy Directive）​ 总的来说A25 adequate level A26 contractual可能出现的案例1.E-mail opt out 2.hack了没通知 3.data retention 4.search转发给third-party A 26 consent比中国法多的情况5. Cookie notice&amp;opt in 类型四：论述分析EU GDPR**和中国法的区别，哪个好？1.EU DPD是综合法omnibus，很全面2.中国是部门法sectoral，规定了各个细节3.列各个法条4.EU好在标准高（Article 25），全面5.中国好在在各个领域规定的很详细Key points should include that sectoral approaches are able to be moretailored to better suit an individual context, while omnibus laws can give clearer rights tothe consumer. Also, student should give consideration to the interface betweenprotecting privacy and stimulating the ecommerce economy. Should an easier approach,as currently taken in China, be preferred in order to keep the burden on businesses to aminimum, or do consumers need stronger, EU style regulation to encourage trust inecommerce (and therefore stimulate the market)?我们这年又考了，还好我考试前看了上边这段答案…（变形题：中国儿童保护的好，美国欧洲保护的不好是不是？**） 类型五：APEC OECD**比较 （变形考HK SAR Data Protection**）推荐不做（也不讲）Vlad and Lucy’s situation should be addressed by application of the Hong Kong Ordinance.Key issues here: Personal data belonging to both Vlad and Lucy has been collected – rights they havein relation to this.o Was this collected in accordance with the processing and collection rules?o How can they expect their information to be treated?o Have these rights been breached? Vlad has been receiving spam emailo Lack of opportunity to indicate preferenceso Are VanHelsing.hk in breach of the law? Lucy’s Credit card hackedo HK Ordinance requires adequate technological protectiono Are BankChan in breach of this?o Hacking alone not proof of deficiency in this area. 总结：一般会降低难度出2个具体的案例，我们的原则是尽可能的做有大量叙述的案例题，少做论文题。]]></content>
      <categories>
        <category>Living</category>
      </categories>
      <tags>
        <tag>大三</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeeCamp2018笔试题第一套A卷]]></title>
    <url>%2F2018%2F06%2F12%2FDeeCamp2018%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A5%97A%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[emmmm，分享一次蜜汁自信结果挫败之旅。 emmmm，刚考完试我是非常自信的，就是很自信，为什么呢？？？我也不知道（疯人疯语ing） 还满怀激动的等待出成绩，出了成绩惊呆了，咋这么低分啊？？？一看，基础题全错了T T emmmm，这个教训告诉我，脚踏实地，该复习复习，该检查检查，该看完全部选项就好好看，不要太自信。 DeeCamp2018在线笔试题第一套A卷 耗时：90分钟答案已加粗 1、有关机器学习分类算法的Precision和Recall，以下定义中正确的是（假定tp = true positive, tn = true negative, fp = false positive, fn = false negative）：【此题仅一个正确选项】(5分) A、Precision = tp / (tp + fp), Recall = tp / (tp + fn)B、Precision = tp / (tn + fp), Recall = tp / (tp + fn)C、Precision = tp / (tn + fn), Recall = tp / (tp + fp)D、Precision = tp / (tp + fp), Recall = tp / (tn + fn) 2、下面有关计算机基本原理的说法中，正确的一项是：【此题仅一个正确选项】(5分) A、堆栈（stack）在内存中总是由高地址向低地址方向增长的。B、发生函数调用时，函数的参数总是通过压入堆栈（stack）的方式来传递的。C、在64位计算机上，Python3代码中的int类型可以表示的最大数值是2^64-1。D、在任何计算机上，Python3代码中的float类型都没有办法直接表示[0,1]区间内的所有实数。 这道题我也不知道自己怎么就蜜汁自信看见A就选了A 3、有关矩阵运算，以下说法中正确的是：【此题仅一个正确选项】(5分) A、矩阵运算可以在并行或分布式系统上以并发方式执行。B、矩阵乘法运算在任何时候都不满足交换律。C、mn 的矩阵在内存或文件中存储时，需要的字节数总是与 mn 成正比。D、空矩阵是指所有元素都为 0 的矩阵。 4、有关 TensorFlow API，以下说法中正确的是：【此题仅一个正确选项】(5分) A、tf.Variable和一般编程语言中“变量（Variable）”的含义完全相同。B、tf.placeholder定义的对象，对应于深度神经网络中的“超参数（Hyperparameter）”。C、通过tf.constant定义的对象，因为是常量，所以，在session.run()运行前就可以用eval()方法获得对象的值。D、session.run()运行一个训练过程时，TensorFlow会使用符号执行（Symbolic Execution）对计算图进行优化。 5、以下哪一个正则表达式不能与字符串“https://www.tensorflow.org/”（不含引号）匹配？【此题仅一个正确选项】(5分) A、[a-z]+://[a-z.]+/B、https[://]www[.]tensorflow[.]org[/]C、[htps]+://www.tensorflow.org/D、[a-zA-Z.:/]+ 脑抽 6、假设可以不考虑计算机运行资源（如内存）的限制，以下 python3 代码的预期运行结果是：【此题仅一个正确选项】(10分) 123456789101112131415import mathdef sieve(size): sieve = [True] * size sieve[0] = False sieve[1] = False for i in range(2, int(math.sqrt(size)) + 1): k = i * 2 while k &lt; size: sieve[k] = False k += i return sum(1 for x in sieve if x)print(sieve(10000000000)) A、455052510B、455052511C、455052512D、455052513 真滴不会T T 7、一个长度为 n 的正整数数列，先递减再递增，如果要找到数列中最小的正整数，最优算法的平均时间复杂度是：【此题仅一个正确选项】(10分) A、O(n)B、O(nlog(n))C、O(log(n^2))D、O(log(n)) 8、一维离散卷积的定义是：给定一维数组 a = [1, 2, 3], v = [4, 5, 6]，它们的离散卷积结果是：【此题仅一个正确选项】(10分) A、[6, 12, 32, 27, 12]B、[4, 13, 28, 24, 18]C、[4, 13, 28, 27, 18]D、[6, 12, 32, 24, 12] 我也不知道自己咋算的呢脑残选了B 9、函数cos(x)的曲线与x轴相交，围成了许多个大小相同的封闭区域（如下图中的阴影区域）。 在每个封闭区域里画矩形，且只考虑矩形的底边与x轴重合的情况。请问，每个封闭区域可以容纳的最大矩形的面积是多少（精确到小数点后三位）？【此题仅一个正确选项】(10分) A、1.571B、0.870C、0.782D、1.122 10、下面这个被污损的二维码中，存储的信息是：【此题仅一个正确选项】(10分) A、Artificial IntelligenceB、Computer ScienceC、Machine LearningD、Deep Learning 11、 有一张图灵奖得主的肖像照片，被一个学生用简单的异或加密方法，编码成了如下这样的字符串： MG4rZiJpImkvaixpLGwrbjRxN3MxdzN3M3s+fTl9OX4EQgdCAUkCSQxID0sJTAtQF1IRVBNWE1sZWhhcGiBnJStrImUmZSFmLGcgZixrKGoobypwKnIwdzJ0Mns/QANCOkAEQQFGAEYMSAxID0oJURVTEVURVhJYGVsYXxheGiIvZSdjJ2MmZyNnI2UvaiNoL2wraitwN3YzczJ7PGstcTR3BEwIRgBEAkkPSA1JDk0LURZVEVQTVBxaH1wZXmUgJ2AkYyZhJGEnZyJiI2ktZi1rL2sobChwPkA7ctWz8ILCv9eeJHYMQgZJA0kMSQhKCFAUUhFVEVQQWhldGF9lXtqf22HanyWeJmAkYyZiImktZy1qLWgxbNSH/K/EhtJlKHYhg+GyIHwFRgBGD0sOTQlOFVIWVRFUE1YZXRldGF/Ymtmd2GHan9uf2mAkYyBmIGcsZClkyJP7ufqJ13MSVANwNGong+6XOX8CRABHDE0OTQhRFFIRVRBUE1sZXBgh2JvfnNmd2JzbnNufJGElYyBlJmg3lC13NHXVkT9c2Y3eidiW23IVSDtuMEcARA1JDUsJTAtTFlURVxNZHl0YXN6a3Z3cm9ma2Z3YnNie2p8kYCd5KnUWdSdt0ogdafTYn5IodyhGfg9rTD91OkcNRg9NDk0LURdSEVUQVxJbGVzflt2V05jemt6b2J3cndic2pw2ejFFI3Mhc9RxPmDTtChObysYJW84RioddzNCA0YNRg9KCFEUUxZSEFQTWBlb05LQk9OV3ZvSl9+a3Jvend2YNW82djFlJZ3XSzVjylR1RxFPGzBoOGpeE3wyfzpHAEcMSwhOFU4WUhFVEFcfWteS1pTWkNCW05vdmd2a35/Ujy9nLGU+h8mUM0Y9RB5OCkcVWAhLGjBpKg5qNH8+fgFGDUYPSglNFVIXVRBUEF3XkNeT1pPXlNKU0ZLSm9yY3I3YY9aU2mE2YC5nBSwAbDJ9AmbZcwlRB2bVlSh6PnwERANJDUsJTwlQFlUWVBJW15HXkNWR1pPXkdeR15XcjP6LJJ/acdJBC2kkvD9HJZfTbM2w2mzZYNKogLU+kzFDBUADSQ1IDkoOTBVTFlQTVNSR1Y/KjtSS1JDWkNWbyrHef9idPU4FVT6f27komNCQyYb5h8qF+LLo3oL3/Wk3eztABkICRgJLCEwVUxZVEFfKkcqPy5HLkNeMyJHXif9obnk4QApTZFgxYMSa3pXdtce48rTto/Ww79S5+79lA3Q5fAdCAUYCRg5MClEXVRBWyYzIi8iQyY3VjM6P1L7QKBFwE1xuJ29BMmDNZcOXxar7sOqimNjnrvSxn8+B2TxAPnw4QAZFAkgMSgpPFFIWVc2JworOi8+NyYvMivhhFyQ/WG4gewcbcQJlxJDQjPSNz7n5gv60+7nnpZrWmsfBQj16OUEHQgBGDE0ITgpTF1LCgsGGwoXCiM2FwYwlb2cmPyxuJkM/FUAUl/FhNZ/Xk/m7woH8tOq29q7/vfXb5HM4ez97BUAGRAJJDEwIUBdSw4TGg8KEwYfMg/iMPkgRKWk2dAFFJgxJK7jpvc6fJbzjq/el77n4u8G876We246XAHU9eztBB0cCSQ9KCUwUVcCHw4DNhsGEwYT4gDgoFFp0N38uZEYGRdWl4a3vt8a7/qjxv/Sq5c6K2pHQiMS6tAd3PXg8fTpDBEcMSw9NFFPGgseFw4TAhsaD/oNgAA1aEzF1UwZtLWnIoOOs6LnxvcO5+rGS25LKus/s0o3MuMszQjB5P3o4QARFA0sJTQpQxIDEg8WCwYPGgPWRQA0GVxBNPWwLY9mV+Ln/s/Wq+4Lzuveh596L2JzN7rzrp5b4/X0+dj94PnwERA1GDEoKTvq++oHGg8eDx4Pom00JBEkYcCNuD2ItbPuFz7n+tfK58rr0oJHEm4H3uva/wonCqpmUP3Y9eD59OkAARgxLCE77vP+/x4HEgcWB6JdIPhZEEkQNSDCaJ2Unl9aHwoj/gPKt7siPiNmGOFEii8xnP3nQiyh3MHk4ezl/B0YNSA9M+br4vfuB+7z+vv6wRxRtfxRPF0QyZSlnPXLfl8+F+bfp1ovc13EnQmhaMpTIexsx2oIreDp7PXs+fgZEAEYPTf66+br7vv66/r3E2gseaFEWRA93IWU6RjlALGPUgfmt6qmWjjhrBV0cIh1m3FRtRsOLNHcxcjJ9PHwGQgFHD0r8u/m6+br5v/u9+6/NO3kpE3s2fy5tA1AIRT9m0ov5rf69JHfbazJHGzlia90kHC4cZyJpKng8dzx9OkABSQxL/bv9uPy9/r3+vPi7m0xMNGpSOHYtbwVXG0QwntWJ6bjccBWR2ihBPlANGHfeRGoMHGshdgd5Nng8ezlBAUgNSvO28rb/uP67/7byuZtIF7rfV0YGRSgOTxFDM3EglPiaMEMpfWkWWhxjeh0m17s4lclo33A+dTB7PHg4QQdHAkjyt/O387bytvy3/bfojvDZlakBPUk4fCJtIDdlIGIgcQ1BNikIUA9XKmlpKCnWlnHFliNuMXExdjx4OEAHRQJI9rT2svC28rjzt/236LEHJB9v6Is6VwBsAyEEq5Le7Z8bWTdn3ZfCiTlZeFQAjIa7/748ZipzM3YzeDh/BUQCRvGz8bPwufG287Xztuy0EScaKwJgPVc2aytlMmnu1uuL32nTmtKOI38teGBEA4+P/OzY1m0ocjB3Mns8ejtFAUf2s/Cz9LX2svOy9rbqpAwzDUFtXAVEFlgUbMyPNZjz1rqo2WnSg9tmJHwPcTSos8OCp8tuKHE3dDx7P38FRQBJ8bLosPSz8bX2tfGy9aAtX9hKSjUPaD5aHncngtx/K6W4xOiR3WXYssZ4P3ou14fJhrYwai5sMHQwdz5/OkUASfWx66/0tPGw6q71r+uq/IvdM0Ig04M5XAJAPWDUjwFl+oCYsceD47LSeAx+INCa3Zq9L2oubTZ0M3Y5fDpAA0fqr+ut6rHqr/Wv9bHqsvyI5XVDK/uwAVQCQiqe3J81TQZAII/sofmRyVA5u+ivJmncmCNoLWw1cjF4P3w6QgFG66zpremt6bH2sPWv9oPwtsrd82w6kjFRF00wZytxMn8DTT11y7XyrikkOXUDRjtyJp4paSxsNXUxdz9+BEAHRemt6a3rsvWs9LPqruiggNE5b4DUyn4OUR1IP2o8fCCfMUcIT97e65wGbh4NUwZydPeJImgvbDVyM3k/fzpAAknoremq6rPqrfWs6LeI/ilRNWswaNNSGV0efD1yKHU0ay1AFX34t8h5Ko4oVw1WSESZuyFqLW00czF7OX0FQgBL6a/pqums6a3or+mz5PDrcCWaAH0BewFdZkkzdCqYN24tbypo0ZUgQMiMJZzIfAN4zYIsayxsNHI9eDx+AUUAS+iq6KruqOms77Hqs5v+r+/wuz9HKW9lWhJEM2slbCOdI2crbdidDW/NYS2UIUTQn9+dLmkvbDVyMnk8fgBHDUntq+mt76ruq+Kx9bfvxYbr6K73cj5eeiUOQzuc2notYydqOWwmfwiSIkI6dw57KnwqhNhwKGordz99OX8GRgJF7KnrpuCo7afhp+uZPdil5ZyQk9sDKGArHX0ybyJtP3kocDV2NlsRRAJNEiRmJGszParwkypvNXY+fDpAAEQAR+6r6avmoem48a7InjpgteS7h8KqDylmJAl6A3cgQAF7PW4ibTsgRwZCCU4PVAQRbiqEzLPddTd4PHoEQDtDA0buqu2q9IHUl8uK05LffvLlo6LNQmteZlUXXTt1PkUycSl1NGgyJlYBayxhSzBl0Z0zmtuYzXAydz16OkE6QABH7qvnrcKTyI/Xh8eGyWUo0aHF9kR5JB9RDCYLdgx9NHwxezpvOShrQjl6N3ImZtqX2WzbatNrOXk8eztBBUAAROyj6ITLhsKEw4fNh82MLJuE5YhNdCsaXhEicUoRTQVCOX88RBUmCHgLUztuKH8siPGAMn3eYAZ5Pnw4fgRBBEXntNWNzInJgfmM1pHWgMJ00P+mqBglbyJlUmotbyUHSgJ/DFkKIBx9FCEEbS91KY/r3zR+I6ggSTB6OH46QQdC/ZfRiMCAw43Dh8uM3pnPljqCs+H+KmAgGUkWMngAaUsHSBdSAVBmVgd4AnMxZyyay7zaQQ3ftXcCdjh+O0EBQ9GY35vNu/6Hy4jEh8idJYwkfsTzpYtiIRBGBF1FDUFdA1EfIxFJFiUIajJ1PXg9ZtiVNlIWt6XYAkA4fgVDB0LRkNeb3JPLiMma0YTDkCJz1nUDjbbh8StkRQdFGzZ9NGdfY1tlWR0pFUcDSTNNAW4+ZQ1cZ72l5stQOUE6QgZBxovMkSWY2GbdjiNy0YTdbypgO23+86XYdioUTgtVGyloI28jdVZnJmRSAn4zUBtSMGQQI2+/pfCKQwZBBUAEfh5KPpbKm9tsIprTfguewGEHZjadyLaz4YEFcVYWQQNPE1VmLm1cZSAYVAxfbysYTAR+YCZsu6HBpJsSfgdDOHotZwROC2wlaCRrJ5cUJSmUPkEhZ8RijtgvQEc1FkoAfTlEHFEWIxxfZFphKWk4CF53SWksa7+h06vaCUA7QTt6peGpoDVXDHAsbDhrLCMSmi9IPWi+YzePVJv5OXdRAHw7RQZACVESWgFQRzxGFxoqRUZqM3KNoMiV4N9QMXsFf7DzreGlpx9TLHcAUytAd0XaShlrpc9waCZNgJtDIBVMDEgGTxxVAnIBL1cUUhdmJnlXczV8iKvzgPDnUjJ3Onyx87fyqOGqfhp5PkYPc24uNEAbUJ3hzi/NldO1fTAXVxZNFVcaSyNQej9XFU4Idyp2IHI1fI+gwYvMv2gMdj95sfOq8LD3pfsXTS1zCXwONAx7ZyLe4aX5xUk9kRMBFl0aTxg5YGgKEU85SxdBAkctayVwMHu9pM2T1remC3s9drbvqeyo7LfhuksInj1HPyxhdRgoAarVlXYeFmnfL3IlElRwPhtobxVDN0MXTQNNMmoueTZ7vLnNkc+M+jZBPXix+bj7tvS286X+F1IpdTBXc30XKDg3Wh5DLHV7ynxRLw1ZeV0AfEwNRzZGF0g9QTJ3OHg9cbqQwZHdm+zHSzx7hcKAopnypvy44eEwAmg/QXVSAykfIHoDfXkZOyiFbjQ/JmtF315ZB0U7RhJLNEUwaTR+CQvfn8Pk15j3nkQyeb/5t8Pio6rxjcWliHB5KXNqKDclcVBiBEYENlxGe8xSYSwIRzA7VwBGO3sTQjlELGMzfQ4oy+zYnNvmyrNoB3ix+7zloqHI1aHFvuEBLzN5bjw3VHshEyxrA3eILS0afmMEGEMSFUwFey58EUsDeTBiNEk18aGaop7N49+lggt5uPy587XgkL+J8Y7ovyQeQxEyClNzLxdMbV19J/2DGjdFCQpiRhZDAnoxegxVPnYwGDRcfpOw7aKeyOGnrNMFew== 已知肖像照片是64x64像素的0~255级灰度图片，内存中用raw bitmap方式，每个像素用一个字节存储。对肖像照片的原始数据，学生使用的加密代码片段如下（Python3代码，代码中的key值是未知的加密密钥）： 12345678_KEY_LEN = 2bitmap = PIL.Image.open(image_path).tobytes()encrypted = []for index, byte in enumerate(bitmap): encrypted.append(byte ^ key[index % _KEY_LEN])return base64.standard_b64encode(bytes(encrypted)) 请问：这张被加密的照片，是以下哪位图灵奖得主的肖像？请从下方A至H的选项中，选择正确答案的字母序号填入： (A) Marvin Minsky(B) John L. Hennessy(C) Donald E. Knuth(D) Raj Reddy(E) John McCarthy(F) Edsger W. Dijkstra(G) John Hopcroft(H) Alan Kay 推荐阅读2018中国高校人工智能人才国际培养计划]]></content>
      <categories>
        <category>Living</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站长日志]]></title>
    <url>%2F2018%2F05%2F06%2F%E7%AB%99%E9%95%BF%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[建站这几个月以来…从网站内容上来看，这个网站起初只是为了记录我在本科阶段的学习过程，尽可能地分享我积累下的学习经历和资源，受众非常局限，可能外人根本不理解我写的都是些什么玩意儿。但现在过去三个月了，对我自己来说受益匪浅。首先是自身专业素养上，得益于此站，经常可以接触到不同系的同学，一起讨论某些课程课业，或者互相答疑解惑；而我的大佬学长 - 问少的小站 - 也给予我各方面的指导，甚至在留言中指出文章中某些问题更好的解决方法，非常感谢！！ 再者是建站过程中，不仅学到了一些没接触过的知识，在交流群中结识了几位小伙伴，有从事近3年Java后台系统开发的培训师，还有和我同一届学嵌入式的郭同学 - 郭某人的博客 - 交流学习上的事情… 建站以来更新的19篇文章，基本上都是课业上的作业，我决定不在这么闭塞了，学点什么都来更新一下，希望未来内容上能越来越好。也希望自己的网站能越来越个性化，所以决定从今天开始写站长日志，记录小站的进步。 网站更新2018.07.16&gt; 修复评论区只显示评论数不显示内容的bug我的网站有两个基于leancloud的应用，一个是访问量统计counter，另一个是基于valine的评论系统blog，期末考完试突然发现评论系统异常，只显示数量不显示具体评论内容，恰逢valine更新，于是去留言区提问了开发者。 然后闲下来了我看了一下leancloud后台，发现counter这个应用不知道为毛线多了一个class叫comment（counter只负责统计访问量，要comment有何用），blog应用下本来也有个comment class，导致valine初始化的时候冲突，我觉得两个各司其职分开比较好，没有采用开发者的建议，直接把counter下的comment class 删掉了。 测试发现回复正常，可喜可贺，感谢开发者，结束~ 2018.05.09&gt; 修改封面照片。忽然发现Avatar和Gravatar不太一致呢，换个好看的。&gt; 修改Safari收藏夹icon。修改default apple-touch-icon，换成了一只猫在篮子里的icon，和我的favicon相呼应~ 2018.05.06&gt; 分享功能：前几天突然发现网站文章后的JiaThis分享链接失效了，今天看了一眼官网… 因公司业务调整，非常遗憾的向大家宣布JiaThis公司决定自2018年4月30日起关闭旗下“分享”业务。 发现JiaThis公司关闭了我所了解到的所有业务：JiaThis分享、友言评论和友荐推选。继网易云跟帖、多说等之后，又一插件系统凉凉。这次果断换百度Share了，因为简单嘛。 打开主题的_config.yml，关闭jiathis，启用baidushare，搞定~ 123456789baidushare: type: button baidushare: true# baidushare: true# type: button# 按照配置文件最开始的格式，会报identation mapping错误，我也不知道为啥开发者要给type一个缩进...我又老老实实改成我喜欢的模式了jiathis: false# 据我所知，源文件里给这些插件写了if else来排序优先级，为了不影响baidushare的解析，我老老实实把其他都false掉了 &gt; 文章排序：上一次想搞排序不记得是什么时候了，然后莫名其妙就搁浅了？因为我同时在更新大二下和大三下的内容，想把大二下的内容搞到下边去，优先显示大三…一开始看了Hexo博文置顶（自定义排序），粘贴了他的代码发现各种问题，首先是UNEXPECTED END OF FILE，发现他贴代码的时候})\;贴到外边去了，在之后报错ReferenceError: posts is not defined，发现是因为他文章里说要加在最后，然而并不是这样（此时我开始怀疑这是他写的代码吗？后面发现果然不是），加上他那代码缩进看得我强迫症都犯了…果断放弃开始RTFSC(read the fucking source code)，然后不报错了，但是并没有什么效果… 然后看了解决Hexo置顶问题，发现这才是代码的出处，这篇文章介绍了两种方法，一个是置顶，一个是top值排序，我倾向于排序而不是几篇文章置顶，所以打算继续使用那几行排序的代码，发现这不就刚才那大哥的代码吗？这次我学机智了不敢直接粘贴，先自己看了一眼，手动加了一下。 找到网站文件夹下的node_modules/hexo-generator-index/lib/generator.js 12345678910111213141516171819202122232425262728293031'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125;else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125;else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125;else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;); &#125;; 只需要在front-matter中设置需要置顶文章的top值，根据top值大小来排序文章。 设置好top值之后，打开git bash: hexo d -g，搞定啦。 &gt; 设置默认front-matter。既然现在我的头部配置多了comments, copyright, top, tags, categories，不如直接修改默认post模板，省的复制粘贴了。找到网站文件夹下的模板文件夹：scaffolds/post.md，修改模板。 123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;comments: truecopyright: truetop: tags:categories:---]]></content>
      <categories>
        <category>Posting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internet Application 9-10:我们中间隔着缓冲区]]></title>
    <url>%2F2018%2F05%2F05%2FInternet%20Application%20Lab9%2F</url>
    <content type="text"><![CDATA[TASK： Write two programs (server and client) so that the server can transfer a local file (indicate by client) to client using TCP. You can design the running command format, e.g., ./&lt;exefile&gt; &lt;server&gt; &lt;filename&gt; The server may be specified in domain name or IP address The transferred file should be indicated by client’s input Client should rename and save the transferred content as a new file Each time the server sends data, following information has to be printed:the destination (client’s IP address and port number)Amount of data that has been sent by “Byte” 代码如下（请勿抄袭）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//SERVER#include &lt;stdio.h&gt; /* for printf() and fprintf() */#include &lt;sys/socket.h&gt; /* for socket(), bind(), sendto()and recvfrom() */#include &lt;arpa/inet.h&gt; /* for sockaddr_in and inet_ntoa() */#include &lt;stdlib.h&gt; /* for atoi() and exit() */#include &lt;string.h&gt; /* for memset() */#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; int sock, serviceSock, QueueLen = 5,fd, fileSize = 0, sendLen,recvLen; struct sockaddr_in echoServAddr; struct sockaddr_in echoClntAddr; unsigned int cliAddrLen; char fileName[100], buffer[100]; unsigned short echoServPort = 6666; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) printf("socket() failed.\n"); memset(&amp;echoServAddr, 0, sizeof(echoServAddr)); memset(&amp;fileName, 0, sizeof(fileName)); echoServAddr.sin_family = AF_INET; echoServAddr.sin_addr.s_addr = htonl(INADDR_ANY); echoServAddr.sin_port =htons(echoServPort); if ((bind(sock, (struct sockaddr *) &amp;echoServAddr, sizeof(echoServAddr))) &lt; 0) printf("bind() failed.\n"); listen(sock, QueueLen); for (;;)&#123; cliAddrLen = sizeof(echoClntAddr); /* Block until receive message from a client */ serviceSock = accept(sock,(struct sockaddr *) &amp;echoClntAddr, &amp;cliAddrLen); printf("***********************************\n"); printf("Accept client %s on TCP port %d\n",inet_ntoa(echoClntAddr.sin_addr),echoServPort); if((recvLen = recv(serviceSock,fileName,100,0)) &gt; 0)&#123; //fileName[strlen(fileName)] = '\0'; wrong code fileName[recvLen] = '\0'; //correct code printf("This client request for file name: %s\n",fileName); fd = open(fileName, O_RDONLY); lseek(fd,0,SEEK_SET); while((sendLen = read(fd, buffer ,10)) &gt; 0)&#123; send(serviceSock, buffer, sendLen, 0); //printf("sendLen - %d\n",sendLen); fileSize += sendLen; &#125; //printf("sendLen - %d\n",sendLen); printf("End of the file \n"); printf("%d BYTES data have been sent. \n", fileSize); close(fd); &#125; close(serviceSock); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//CLIENT#include &lt;stdio.h&gt; /* for printf() and fprintf() */#include &lt;sys/socket.h&gt; /* for socket(), sendto() andrecvfrom() */#include &lt;arpa/inet.h&gt; /* for sockaddr_in and inet_addr() */#include &lt;stdlib.h&gt; /* for atoi() and exit() */#include &lt;string.h&gt; /* for memset() */#include &lt;unistd.h&gt; /* for close() */#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; int sock,fd,fileSize = 0,recvLen; struct sockaddr_in echoServAddr; unsigned short echoServPort = 6666; char *servIP, *fileName; char *buffer[100]; if ( argc != 3 )&#123; printf("Usage: %s &lt;Server IP&gt; &lt;File Name&gt; ...\n",argv[0]); exit(1); &#125; servIP = argv[1]; /* First arg: server IP address (dotted quad) */ if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) printf("socket() failed.\n"); memset(&amp;echoServAddr, 0, sizeof(echoServAddr)); echoServAddr.sin_family = AF_INET; echoServAddr.sin_addr.s_addr = inet_addr(servIP); echoServAddr.sin_port = htons(echoServPort); printf("Connecting to server: %s\n", argv[1]); if (connect(sock,(struct sockaddr *) &amp;echoServAddr, sizeof(echoServAddr)) &lt; 0)&#123; printf("Can Not Connect To %s!\n", argv[1]); exit(1); &#125; if (send(sock, argv[2], strlen(argv[2]), 0)!= strlen(argv[2]))&#123; printf("send() sent a different number of bytes than expected.\n"); exit(1); &#125;else printf("Request for file \"%s\" has been sent.\n",argv[2]); fileName = strcat(argv[2],".bak"); fd = open(fileName, O_RDWR|O_CREAT,0644); printf("Connecting to the server...\n"); memset(buffer,0,sizeof(buffer)); while((recvLen = recv(sock, buffer, 10, 0)) &gt; 0)&#123; write(fd, buffer, recvLen); //printf("recvLen - %d\n",recvLen); fileSize += recvLen; &#125; close(fd); close(sock); printf("file received.\n %d bytes received, and stored in %s \n",fileSize,fileName); exit(0);&#125; 运行结果（怕暴露把IP地址隐匿了一部分）：需要提前生成测试用的两个文件：test.txt, testc.cpp 1234567891011121314151617SERVER TEST student@BUPTIA:~/tcp$ ./s***********************************Accept client 10.109.242.* on TCP port 6666This client request for file name: test.txtEnd of the file 48 BYTES data have been sent. ***********************************Accept client 10.109.242.* on TCP port 6666This client request for file name: testc.cppEnd of the file 132 BYTES data have been sent. ***********************************Accept client 10.109.242.* on TCP port 6666This client request for file name: cEnd of the file 7917 BYTES data have been sent. 12345678910111213141516171819CLIENT TEST student@BUPTIA:~/tcp$ ./c 10.109.242.* test.txtConnecting to server: 10.109.242.*Request for file "test.txt" has been sent.Connecting to the server...file received. 48 bytes received, and stored in test.txt.bak student@BUPTIA:~/tcp$ ./c 10.109.242.* testc.cppConnecting to server: 10.109.242.*Request for file "testc.cpp" has been sent.Connecting to the server...file received. 84 bytes received, and stored in testc.cpp.bak student@BUPTIA:~/tcp$ ./c 10.109.242.* cConnecting to server: 10.109.242.211Request for file "c" has been sent.Connecting to the server...file received. 7785 bytes received, and stored in c.bak 12345678910111213141516171819202122232425262728293031323334353637383940RESULT student@BUPTIA:~/tcp$ lltotal 60drwxrwxr-x 2 student student 4096 May 5 22:54 ./drwxr-xr-x 13 student student 4096 May 5 22:54 ../-rwxrwxr-x 1 student student 7785 May 5 22:35 c*-rw-r--r-- 1 student student 1881 May 5 22:34 c.cpp-rwxrwxr-x 1 student student 7895 May 5 22:35 s*-rw-r--r-- 1 student student 1958 May 5 22:32 s.cpp-rw-r--r-- 1 student student 12288 May 5 19:41 .s.cpp.swp-rw-r--r-- 1 student student 48 May 5 21:19 test.txt-rw-r--r-- 1 student student 48 May 5 22:54 test.txt.bak-rw-r--r-- 1 student student 84 May 5 22:28 testc.cpp-rw-r--r-- 1 student student 84 May 5 22:59 testc.cpp.bakstudent@BUPTIA:~/tcp$ od -c test.txt0000000 t h i s i s a t e s t f0000020 i l e . \n t h i s i s a t0000040 e s t f i l e . \n o v e r . \n0000060student@BUPTIA:~/tcp$ od -c test.txt.bak0000000 t h i s i s a t e s t f0000020 i l e . \n t h i s i s a t0000040 e s t f i l e . \n o v e r . \n0000060student@BUPTIA:~/tcp$ od -c testc.cpp0000000 # i n c l u d e &lt; s t d i o .0000020 h &gt; \n \n i n t m a i n ( ) \n0000040 &#123; \n p r i n t f ( " H e0000060 l l o , W o r l d ! \ n " )0000100 ; \n \n r e t u r n 00000120 ; \n &#125; \n0000124student@BUPTIA:~/tcp$ od -c testc.cpp.bak0000000 # i n c l u d e &lt; s t d i o .0000020 h &gt; \n \n i n t m a i n ( ) \n0000040 &#123; \n p r i n t f ( " H e0000060 l l o , W o r l d ! \ n " )0000100 ; \n \n r e t u r n 00000120 ; \n &#125; \n0000124 QUESTIONSQ: 为什么我把上一个UDP的实验改成TCP以后，一次传输multiple words会被TCP一次性接收到一个buffer里？A: 对于UDP，一个recvfrom()对应一个sendto()，sendto()执行了4次，那么recvfrom()也会相应的执行4次； UDP的sendto对应着recvfrom,一发一收.如果sendto的数据大于MTU,则会在IP层分片发送,到达目标后由IP层重组,再从recvfrom一次性返回.如果使用IP层分片重组则存在乱序,丢包,重包的问题.调用一次sendto,只要数据长度小于MTU都会以一个独立的UDP包发送.recvfrom的接收大小必须大于或等于sendto时的是数据大小.更正确的说法应该是UDP的包单位是以IP层的包为单位的. —— 参见文末“推荐阅读” 对于TCP，每一个socket在被创建之后，系统都会给它分配两个缓冲区，即输入缓冲区和输出缓冲区。 数据的发送和接收是独立的，并不是发送方执行一次send，接收方就执行一次recv。recv函数不管发送几次，都会从输入缓冲区尽可能多的获取数据。如果发送方发送了多次信息，接收方没来得及进行recv，则数据堆积在输入缓冲区中，取数据的时候会都取出来。换句话说，recv并不能判断数据包的结束位置。 —— 参见文末“推荐阅读” 推荐阅读腾讯面试题：TCP与UDP的Send和Recvsend和recv只是内核缓冲区和应用程序缓冲区之间的搬运工—严格来讲send和recv并不具备发送和接收功能 send与recv 缓冲区与阻塞]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internet Application 6-7:你们一家人长得可真像]]></title>
    <url>%2F2018%2F04%2F17%2FInternet%20Application%20Lab6%2F</url>
    <content type="text"><![CDATA[TASK： Write the programs for data sending based on UDP You can design the running command format, e.g.,./&lt;exefile&gt; &lt;server&gt; &lt;data&gt; The server may be specified in domain name or IP address Multiple wordscan be delivered each time Each time the server receives data, the source (client’s IP address and port number) and the data should be displayed on the screen 代码如下（请勿抄袭）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//EchoClient.cpp#include &lt;stdio.h&gt; /* for printf() and fprintf() */#include &lt;sys/socket.h&gt; /* for socket(), sendto() andrecvfrom() */#include &lt;arpa/inet.h&gt; /* for sockaddr_in and inet_addr() */#include &lt;stdlib.h&gt; /* for atoi() and exit() */#include &lt;string.h&gt; /* for memset() */#include &lt;unistd.h&gt; /* for close() */#define ECHOMAX 255 /* Longest string to echo */int main(int argc, char *argv[])&#123; int sock; struct sockaddr_in echoServAddr; unsigned short echoServPort = 6666; char *servIP; char *echoString[20]; char echoBuffer[20][ECHOMAX+1]; int echoStringLen[20]; int respStringLen[20]; int i=0; if ( argc &lt; 3 )&#123; printf("Usage: %s &lt;Server IP&gt; &lt;Echo Word&gt; &lt;Echo Word&gt; ...\n",argv[0]); exit(1); &#125; servIP = argv[1]; /* First arg: server IP address (dotted quad) */ for(;i&lt;20;i++)&#123; if(argv[i+2] != NULL &amp;&amp; (strlen(argv[i+2])&lt;=ECHOMAX))&#123; echoStringLen[i]=strlen(argv[i+2]); echoString[i] = argv[i+2]; &#125;else if(argv[i+2] != NULL &amp;&amp; (echoStringLen[i]=strlen(argv[i+2])&gt;ECHOMAX))&#123; printf("Echo word too long.\n"); break; &#125; else break; &#125; if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0) printf("socket() failed.\n"); memset(&amp;echoServAddr, 0, sizeof(echoServAddr)); echoServAddr.sin_family = AF_INET; echoServAddr.sin_addr.s_addr = inet_addr(servIP); echoServAddr.sin_port = htons(echoServPort); printf("%s: Sending data to \"%s\"\n",argv[0],argv[1]); for(int j=0;j&lt;i;j++)&#123; if ((sendto(sock, echoString[j], echoStringLen[j], 0,(struct sockaddr *) &amp;echoServAddr, sizeof(echoServAddr)))!= echoStringLen[j]) &#123; printf("sendto() sent a different number of bytes than expected.\n"); break; &#125;else continue; &#125; close(sock); exit(0);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//EchoServer.cpp#include &lt;stdio.h&gt; /* for printf() and fprintf() */#include &lt;sys/socket.h&gt; /* for socket(), bind(), sendto()and recvfrom() */#include &lt;arpa/inet.h&gt; /* for sockaddr_in and inet_ntoa() */#include &lt;stdlib.h&gt; /* for atoi() and exit() */#include &lt;string.h&gt; /* for memset() */#include &lt;unistd.h&gt;#define ECHOMAX 255 /* Longest string to echo */int main(int argc, char *argv[])&#123; int sock; struct sockaddr_in echoServAddr; struct sockaddr_in echoClntAddr; unsigned int cliAddrLen; char echoBuffer[20][ECHOMAX]; unsigned short echoServPort = 6666; int recvMsgSize[20]; printf("Port Number: %d\n",echoServAddr.sin_port); if ((sock = socket(PF_INET, SOCK_DGRAM, 0)) &lt; 0) printf("socket() failed.\n"); memset(&amp;echoServAddr, 0, sizeof(echoServAddr)); echoServAddr.sin_family = AF_INET; echoServAddr.sin_addr.s_addr = htonl(INADDR_ANY); echoServAddr.sin_port =htons(echoServPort); if ((bind(sock, (struct sockaddr *) &amp;echoServAddr, sizeof(echoServAddr))) &lt; 0) printf("bind() failed.\n"); printf("Server Address: %s\n",inet_ntoa(echoServAddr.sin_addr)); printf("%s: waiting for data on port UDP %d \n",argv[0],echoServPort); for (;;)&#123; cliAddrLen = sizeof(echoClntAddr); /* Block until receive message from a client */ for(int i=0;i&lt;20;i++)&#123; if ((recvMsgSize[i] = recvfrom(sock, echoBuffer[i], ECHOMAX,0,(struct sockaddr *) &amp;echoClntAddr, &amp;cliAddrLen)) &lt; 0) printf("recvfrom() failed.\n"); printf("%s: from %s: UDP%d: %s\n",argv[0],inet_ntoa(echoClntAddr.sin_addr),echoClntAddr.sin_port,echoBuffer[i]); &#125; &#125;&#125; 运行结果（怕暴露把IP地址隐匿了一部分）：12student@BUPTIA:~/lab6/test2$ ./EchoClient 10.128.*.192 hello? who are you?./EchoClient: Sending data to "10.128.*.192" 12345678student@BUPTIA:~/lab6/test2$ ./EchoServerPort Number: 2052Server Address: 0.0.0.0./EchoServer: waiting for data on port UDP 6666 ./EchoServer: from 10.128.*.192: UDP24719: hello?./EchoServer: from 10.128.*.192: UDP24719: who./EchoServer: from 10.128.*.192: UDP24719: are./EchoServer: from 10.128.*.192: UDP24719: you? in_addr、inet_addr()和inet_aton()长得可真像in_addr123456789//32-bit IPv4 addresses are stored in an IP Address structure.//defined in &lt;netinet/in.h&gt;typedef uint32_t in_addr_t;struct in_addr &#123; in_addr_t s_addr;&#125;;//defined in&lt;stdint.h&gt;typedef unsigned int uint32_t; in_addr是一个表示IP地址的结构体类型，而这个结构体中只包含一个元素：一个类型为unsigned int/uint32_t/in_addr_t的s_addr(真正的32位IP地址本尊)。 问：为什么IP地址的表示非要用in_addr这种结构体类型，且结构体里还只有一个元素？答：历史原因。早期版本（4.2BSD）把in_addr结构定义为多种结构的union，允许访问一个32位IPv4地址中的所有4个字节，或者访问它的两个16位值，因为那时候采用分类地址，便于获取地址中的适当字节。后来我们有CIDR了，不需要分类了，就废除了该union，仅让它包含一个in_addr_t类型的字段。 问：以前学C语言的时候unsigned int不应该是16位吗？？？怎么成32位了？答：查询整形数据常见存储空间和值的范围得知，unsigned int有两种情况（2-byte和4-byte），我们在这里使用的是uint32_t，是4-byte即32位。附两位网友的发言： C语言标准并未规定这些基本数据类型的长度，其具体长度与编译器以及所在的平台（86，ARM等等）有关。 一般数据类型有的占有的字节的数跟编译器有关，并不和你的电脑室32位呀，64位呀有关，千万别以为你的电脑是64位的就应该比32位的数据类型占用高一些，那大家都用64位机写的东西是不是在32位上同一个编译器都溢出了？那样恐怕不好吧，另外，64位的系统也可以装32位的编译器，例如，64位系统可以装xp，32位机器上可以有16/32位的编译器（XP上有tc是16位的，其他常见的是32位的），即使是32位的编译器也可以弄出64位的integer来（int64）。 所以请记住，数据类型所占直接主要由编译器决定(占多少位由编译器在编译期间说了算)， 数据类型所占的字节数完全是和你用什么编译器有关的，编译器不一样，所分配给数据类型的字节数也会有所不同。 inet_addr()1234//inet_addr()函数原型：//defined in &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *strprt);//返回值说明：若字符串有效则返回为32位二进制网络字节序的IPv4地址，否则为INADDR_NONE inet_addr()是一个函数，用来将strptr所指的字符串转换成32位二进制网络字节序的IPv4地址。该函数存在一个问题，所有2^32个可能的二进制值都是有效的IP地址（0.0.0.0~255.255.255.255），但是出错时函数返回的INADDR_NONE（通常是一个32位均为1的值）。这意味着点分十进制串255.255.255.255(broadcast address)不能由该函数处理。 并且一些手册说该函数出错时返回-1而不是INADDR_NONE。这种情况下对该函数的返回值（一个无符号的值）和一个负常值（-1）进行比较时可能会发生问题，具体取决于C编译器。 书上说如今inet_addr已经被废弃，逐渐改用inet_aton()函数。 inet_aton()1234//inet_aton()函数原型//defined in &lt;arpa/inet.h&gt;int inet_aton(const char *strptr, struct in_addr *addrptr);//返回值说明：若字符串有效则为1，否则为0 inet_aton()是一个函数，干着和inet_addr类似的事情：将strptr所指的字符串转换成32位二进制网络字节序的IPv4地址，并通过*addrptr来存储。 inet_aton()有一个没有写入正式文档的特征：如果*addrptr为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。【这仿佛一句废话】 套接字地址结构大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义它自己的套接字地址结构。这些结构的名字以sockaddr_开头，并对应每个协议族的唯一后缀结尾。 IPv4套接字地址结构1234567//sockaddr_in, Internet-specific socket address(bits/socket.h)struct sockaddr_in &#123; unsigned short sin_family; /* address family (always AF_INET),2 byte */ unsigned short sin_port; /* port num in network byte order,2 byte */ struct in_addr sin_addr; /* IP addr in network byte order, 4 byte */ unsigned char sin_zero[8]; /* pad to sizeof(struct sockaddr), 8 byte */&#125;; 通用套接字地址结构123456struct sockaddr &#123; unsigned short sa_family; /* protocol family */ char sa_data[14]; /* protocol-specific address, up to 14 bytes. */&#125;;//Pointer to generic socket address is used for address//arguments to connect(), bind() and accept() 问：为什么我们要用到通用套接字地址结构？答：使用套接字函数时，要把套接字地址结构的指针作为参数传递给套接字函数，然而这样的话不同类型的套接字就需要以不同类型套接字结构指针作为参数的函数，为了方便我们直接定义一个通用的，调用时参数直接转型就好了。 其他相关原型：1234//memset()函数原型//defined in &lt;string.h&gt;void *memset(void *dest, int c, size_t len);//memset()把目标字节串指定数目的字节置为值c。 今日思考：1.TCP：如果Server接收了几个请求，并在同一个端口上为它们一人建立了一个Socket方便通信，这些Socket要怎么区分？ socket不需要得到区分，connection能区分就行了。2.FTP：如果Server接收了几个请求，并随机开新端口为它们一人建立了一个Socket方便通信，容易有什么后果？3.UDP：只把Server的Socket和sockaddr_in通过bind()绑在一块了，Client的socket该咋办？光溜溜只有一个socket descriptor要怎么查看它挂在哪个端口上？ 确实没办法？ 推荐阅读in_addr 的用法TCP server 为什么一个端口可以建立多个连接？]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internet Application 5:绝情的指针]]></title>
    <url>%2F2018%2F04%2F17%2FInternet%20Application%20Lab5%2F</url>
    <content type="text"><![CDATA[TASK 1: Find the fore-mentioned header files in your system in.h, types.h, netdb.h, endian.h, socket.h,… 12student@BUPTIA:~$ locate in.hstudent@BUPTIA:~$ sudo find / -name in.h 使用locate或者find命令，输出结果略… TASK 2: Find the host byte order of your machine代码如下：1234567891011121314151617181920212223#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; union&#123; short s; char c[sizeof(short)]; &#125;un; un.s = 0x0102; if(sizeof(short) == 2)&#123; if(un.c[0]==1&amp;&amp;un.c[1]==2) printf("big-endian\n"); else if(un.c[0]==2&amp;&amp;un.c[1]==1) printf("little-endian\n"); else printf("unknown\n"); &#125;else printf("sizeof(short) = %d\n", sizeof(short)); exit(0);&#125; 运行结果：123student@BUPTIA:~/lab5$ gcc HostOrder.c -o HostOrderstudent@BUPTIA:~/lab5$ ./HostOrderlittle-endian TASK 3: Use “man” to learn the usage of netstat, ifconfig, ping, traceroute 1234netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast membershipsifconfig - configure a network interfaceping, ping6 - send ICMP ECHO_REQUEST to network hoststraceroute - print the route packets trace to network host TASK 4: Write a program to find the host information of a given hostThe host is specified in domain name: ./&lt;exefile&gt; www.baidu.comYour program shall list the official name, all the aliases, the address type, the address length, all the IP address in numbers-and-dots format. 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; struct hostent *hostinfo; struct in_addr *ip; if (argc != 2) &#123; printf("Usage:\n%s hanxueying.com\n", argv[0]); exit(1); &#125; //lookup host infomation by domain name. hostinfo = gethostbyname(argv[1]); //print hostinfo-&gt;h_name here. printf("The official name is: %s \n",hostinfo-&gt;h_name); //print hostinfo-&gt;h_aliases here. char **addr_aliases = hostinfo-&gt;h_aliases; for(int j=0;addr_aliases[j]!=NULL;j++) printf("Aliases: %s\n",addr_aliases[j]); //print hostinfo-&gt;h_addrtype here. if(hostinfo-&gt;h_addrtype == AF_INET) printf("The type is IPv4.\n"); else if(hostinfo-&gt;h_addrtype == AF_INET6) printf("The type is IPv6.\n"); else printf("Unknown.\n"); //print hostinfo-&gt;h_length here. printf("the length is:%d \n",hostinfo-&gt;h_length); //print hostinfo-&gt;h_addr_list here. char **addr_list = hostinfo-&gt;h_addr_list; for(int i=0; addr_list[i]!=NULL; i++)&#123; ip = (struct in_addr *)(addr_list[i]); printf("%s\n", inet_ntoa( *ip )); &#125; return 0;&#125; 运行结果：123456student@BUPTIA:~/lab5$ ./hostent www.hanxueying.comThe official name is: www.hanxueying.com The type is IPv4.the length is:4 104.24.111.179104.24.110.179 问：为什么写c程序的时候，一把for循环里的i，j写在里边就报错？ error: ‘for’ loop initial declarations are only allowed in C99 mode答：你把文件名从xxx.c改成xxx.cpp就行了。学长的教导：在gcc编译的时候加上一个参数-std=c99就可以正常编译那个i,j在for内声明的情况了，而不用修改后缀cpp。 问：inet_ntoa()返回的是指针，拿printf打印指针会是什么效果？答：几种常见情况如下：12345678910111213int a = 10;int *p = &amp;a;char *b = "test"; char c = 'a';printf("%d \n", a); //输出a的值10printf("%d \n", p); //输出p的值，因为p是指针，即输出的是a的地址。printf("%d \n", *p); //输出p指针指向的内容的值。因为p指向了a，所以输出a的值10。printf("%d \n", b); //输出地址 printf("%s \n", b); //输出内容"test" printf("%c \n", *b); //输出单个字符't'/* printf("%s \n", *b); 会crash，因为此时*b是单个字符't' *///指针变量在声明的时候，例如int *p = &amp;a，并不表示把&amp;a赋给*p，而是表示把&amp;a赋给p，因为*仅表示这是一个指针。//p是指针变量，即指向a的那个指针；*p是指向内容的值，即a变量实体。 相关原型：123456789struct hostent &#123; char *h_name; /* official name of host */ char **h_aliases; /* pointer to alternate host name array */ int h_addrtype; /* address type */ int h_length; /* length in bytes of address */ char **h_addr_list; /* pointer to array of network addresses */&#125;; #define h_addr h_addr_list[0] /* the first address in the address list */ 1234//inet_ntoa()函数原型：//defined in &lt;arpa/inet.h&gt;char * inet_ntoa(struct in_addr inaddr);//返回值说明：返回一个点分十进制数串的指针 进阶：使用IPv4地址或域名查询（没考虑管理员没注册导致返回空指针的问题，所以测试用8.8.8.8） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; struct hostent *hostinfo; struct in_addr address; if (argc != 2) &#123; printf("Usage:\n%s hanxueying.com\n", argv[0]); exit(1); &#125;else if(inet_aton(argv[1], address) == 1) hostinfo = gethostbyaddr(&amp;address, sizeof(address), AF_INET); else if(gethostbyname(argv[1]) != NULL) hostinfo = gethostbyname(argv[1]); else&#123; printf("Neither valid IPv4 address, nor valid domain name.\n"); exit(1); &#125; //print hostinfo-&gt;h_name here. printf("The official name is: %s \n",hostinfo-&gt;h_name); //print hostinfo-&gt;h_aliases here. char **addr_aliases = hostinfo-&gt;h_aliases; for(char **aptr=hostinfo-&gt;h_aliases; *aptr != NULL; aptr++) printf("Aliases: %s\n",*aptr); //print hostinfo-&gt;h_addrtype here. if(hostinfo-&gt;h_addrtype == AF_INET) printf("The type is IPv4.\n"); else if(hostinfo-&gt;h_addrtype == AF_INET6) printf("The type is IPv6.\n"); else printf("Unknown.\n"); //print hostinfo-&gt;h_length here. printf("The length is:%d \n",hostinfo-&gt;h_length); //print hostinfo-&gt;h_addr_list here. for(char **pptr=hostinfo-&gt;h_addr_list; *pptr!=NULL; pptr++)&#123; //printf("%s\n", inet_ntoa(*(struct in_addr *) *pptr ) ); printf("%s\n", inet_ntoa(*(struct in_addr *)*hostinfo-&gt;h_addr_list)); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; struct hostent *hostinfo; struct in_addr address; if (argc != 2) &#123; printf("Usage:\n%s hanxueying.com\n", argv[0]); exit(1); &#125;else if(inet_aton(argv[1], address) == 1) hostinfo = gethostbyaddr(&amp;address, sizeof(address), AF_INET); else if(gethostbyname(argv[1]) != NULL) hostinfo = gethostbyname(argv[1]); else&#123; printf("Neither valid IPv4 address, nor valid domain name.\n"); exit(1); &#125; //print hostinfo-&gt;h_name here. printf("The official name is: %s \n",hostinfo-&gt;h_name); //print hostinfo-&gt;h_aliases here. char **addr_aliases = hostinfo-&gt;h_aliases; for(char **aptr=hostinfo-&gt;h_aliases; *aptr != NULL; aptr++) printf("Aliases: %s\n",*aptr); /* while ((hostinfo-&gt;h_aliases)[0]) printf("Host aliases: %s\n", *hostinfo-&gt;h_aliases++); */ //print hostinfo-&gt;h_addrtype here. if(hostinfo-&gt;h_addrtype == AF_INET) printf("The type is IPv4.\n"); else if(hostinfo-&gt;h_addrtype == AF_INET6) printf("The type is IPv6.\n"); else printf("Unknown.\n"); //print hostinfo-&gt;h_length here. printf("The length is:%d \n",hostinfo-&gt;h_length); //print hostinfo-&gt;h_addr_list here. for(char **pptr=hostinfo-&gt;h_addr_list; *pptr!=NULL; pptr++)&#123; //printf("%s\n", inet_ntoa(*(struct in_addr *) *pptr ) ); printf("%s\n", inet_ntoa(*(struct in_addr *)*hostinfo-&gt;h_addr_list)); &#125; /* while ((hostinfo-&gt;h_addr_list)[0]) printf("IP address: %s\n", inet_ntoa(*(struct in_addr *) *hostinfo-&gt;h_addr_list++)); */ return 0;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internet Application 4:O_APPEND到底移不移偏移量]]></title>
    <url>%2F2018%2F04%2F01%2FInternet%20Application%20Lab4%2F</url>
    <content type="text"><![CDATA[Task 1Learn about the O_APPEND flag of open(). Please write a program to append one file to another file with open() and lseek(). 12345678910111213141516171819202122232425#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main(void)&#123; char buf[10]; int fd1,fd2,count=0; if((fd1 = open("file1",O_RDWR|O_APPEND,0644)) == -1) printf("Error in opening file1\n"); if((fd2 = open("file2",O_RDWR,0644)) == -1) printf("Error in opening file2\n"); while(read(fd2,buf,1)!= 0)&#123; write(fd1,buf,1); count++; &#125; printf("file2 has %d char.\n",count); close(fd1); close(fd2); return 0; &#125; 12345678910111213student@BUPTIA:~/append$ cat &gt; file11234567890abcdefghijstudent@BUPTIA:~/append$ cat &gt; file2##########@@@@@@@@@@student@BUPTIA:~/append$ ./append1file2 has 22 char.student@BUPTIA:~/append$ cat file11234567890abcdefghij##########@@@@@@@@@@ 从这个实例看来，如果我们在open()的flag里加上O_APPEND，在写入内容时不需要lseek，就会自动把内容写入到文件末尾，毕竟APPEND本意就是附加嘛。 Task 2When using O_APPEND to open a file for reading and writing, can we read the file from any location using lseek()? Can we update the data in any part of the file using lseek()? Please write a program to verify your answer. 12345678910111213141516171819202122232425262728293031323334353637#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; char buf[10],temp[10]; int fd,offset,count=0,update,a=0; if((fd = open("file2seek.txt",O_RDWR|O_APPEND)) == -1) printf("Error in opening file\n"); printf("we will read the rest of one line from the position you point.\n"); printf("please input the position you want to read from the file:"); scanf("%d",&amp;offset); printf("the new offset is = %d\n",offset); if(lseek(fd,offset,SEEK_SET)==-1)&#123; printf("lseek error"); exit(1); &#125; while(buf[0]!='\n')&#123; read(fd,buf,1); temp[a] = buf[0]; a++; &#125; temp[a] = '\0';//printf()以'\0'作为输出结束符，如果不强制给它加个结尾，后续打印会出乱码。 printf("%d bytes have been read, the read content is: %s\n",a-1,temp); printf("we will insert ***** into the position you point\n"); printf("Please input the begining point you want to update the file:"); scanf("%d",&amp;update); lseek(fd,update,SEEK_SET); write(fd,"*****",5); close(fd);&#125; 12345678910111213141516171819student@BUPTIA:~/append$ vi task2.cstudent@BUPTIA:~/append$ gcc task2.c -o task2student@BUPTIA:~/append$ cat &gt; file2seek.txt1234567890abcdefghij##########student@BUPTIA:~/append$ ./task2we will read the rest of one line from the position you point.please input the position you want to read from the file:18the new offset is = 183 bytes have been read, the read content is: hijwe will insert ***** into the position you pointPlease input the begining point you want to update the file:12student@BUPTIA:~/append$ cat file2seek.txt1234567890abcdefghij##########*****student@BUPTIA:~/append$ O_APPEND的含义：第二个task让我们自己验证，如果使用了O_APPEND：是否可以利用lseek从任意位置read?是否可以用lseek任意write?从运行结果可以看出，此时可以利用lseek从任意位置read，但不能write。这看起来也很合理，附加只允许附加到结尾，中间的插入是无效的，但这不影响读。 O_APPEND的原理：1)有人觉得：写了O_APPEND会在一开始把文件中的指针移到了文件尾，以方便从文件尾添加数据。我觉得显然行不通，第二个实例中read前面的lseek()显然把文件指针移到了想要的位置，后边遇到write又不能移了，说不通呀。2)还有人觉得：可能O_APPEND会把文件的指针移到文件末尾，如果中途使用了lseek()来读，则允许移动指针，如果使用lseek()来写，则lseek失效，文件指针还在结尾。我觉得也很扯，总不能执行完lseek()在观察下一步是读还是写，是写就撤销吧？那要是我写一个lseek()在写点别的隔几行在write，系统岂不是懵逼了？3)所以现在最大的问题就是，O_APPEND到底移动不移动偏移量？我们不妨写个程序试试。 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; int main(void) &#123; int fd; off_t off; printf("Not using O_APPEND:\n"); fd = open("./test.c", O_WRONLY); off = lseek(fd, 0, SEEK_SET); printf("The offset of SEEK_SET is %d.\n", off); close(fd); fd = open("./test.c", O_WRONLY); off = lseek(fd, 0, SEEK_END); printf("The offset of SEEK_END is %d.\n", off); close(fd); fd = open("./test.c", O_WRONLY); off = lseek(fd, 0, SEEK_CUR); printf("The offset of SEEK_CUR is %d.\n", off); close(fd); printf("Using O_APPEND:\n"); fd = open("./test.c", O_WRONLY | O_APPEND); off = lseek(fd, 0, SEEK_SET); printf("The offset of SEEK_SET is %d.\n", off); close(fd); fd = open("./test.c", O_WRONLY | O_APPEND); off = lseek(fd, 0, SEEK_END); printf("The offset of SEEK_END is %d.\n", off); close(fd); fd = open("./test.c", O_WRONLY | O_APPEND); off = lseek(fd, 0, SEEK_CUR); printf("The offset of SEEK_CUR is %d.\n", off); close(fd); exit(0); ｝ 测试结果123456789Not using O_APPEND:The offset of SEEK_SET is 0.The offset of SEEK_END is 49. //文件长度为49The offset of SEEK_CUR is 0.Using O_APPEND:The offset of SEEK_SET is 0.The offset of SEEK_END is 49.The offset of SEEK_CUR is 0.//注意：在O_APPEND情况下调用lseek(fd, 0, SEEK_CUR) //输出的结果是0 通过最后一行打印结果，可以看出来O_APPEND根本没有移动偏移量，当前指针位置还是在文件开头。 查询得知： 每个进程有一个打开文件描述符表，而该表的表项中有一个文件状态标志，当前文件偏移量和一个v节点指针，v节点指针指向一个v节点表，而该表中的i节点信息中有一个当前文件长度。 对于lseek来说，它直接修改文件描述符表项中的当前文件偏移量，并返回当前的文件偏移量，而对于O_APPEND标志，则只是将其设置到了文件表项的文件状态标志中，此时当前文件偏移量并未修改，仍然为0，只有当用户企图写入文件时，才将文件当前偏移量置为文件长度。这从另一个角度说明，如果文件以O_APPEND标志打开，则lseek对该文件的写将不起作用，因为无论lseek怎样调整当前文件偏移量，在写入时仍然会被设为文件长度而将内容添加在文件尾。 思考对于我们的Task 2，如果在代码最后多加一行打印一下当前文件指针的偏移量，是12还是文件的末尾呢？答案：12，惊不惊喜，意不意外？ 推荐阅读关于打开文件时O_APPEND标志的作用]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Internet Application 3:爷爷-爸爸-你的神秘旅程]]></title>
    <url>%2F2018%2F03%2F25%2FInternet%20Application%20Lab3%2F</url>
    <content type="text"><![CDATA[fork1.c1234567891011#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt; //此头文件包含了fork()#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; pid_t t; t=fork(); printf("fork returned %d\n",t); exit(0);&#125; 123student@BUPTIA:~/fork$ ./fork1fork returned 1224student@BUPTIA:~/fork$ fork returned 0 （1）为什么同样是c语言，这个例子不可以直接在c-free里编译运行呢？ 答：fork()这个函数来自Unix的函数库，所以在Windows下不支持，Windows上创建进程一般使用CreateProcess函数。 （2）fork()的返回值传给了t，返回值是怎样的？ 1）在父进程中，fork返回新创建子进程的Process ID；2）在子进程中，fork返回0；3）如果出现错误，fork返回一个负值； （3）出现错误，返回负值的原因 可能有两种原因：​ 1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。 2）系统内存不足，这时errno的值被设置为ENOMEM。 （4）为什么多次运行的打印顺序不一样？ 答：和Java多线程一样，创建新进程成功后，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。 （5）为什么我gcc完老师的代码报了一堆错？ 太久不碰c语言我们可能忘了编译器的提示会有两种错误(error)和警告(warning)，警告是可以无视的，不会影响运行的。比如老师的代码里使用了I/O相关的函数但是没有在头部引入，gcc就会给你甩个warning然后自己默默enable这个函数… fork11.c — 拓展123456789101112#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt; #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; pid_t t1,t2; t1=fork(); //这句话之后，共有两个进程：父进程、父进程产生的子进程。 t2=fork(); //这句话会被上边的两个进程都执行，所以又产生了两个新的进程：父进程产生的第二个子进程、父进程产生的第一个子进程的子进程。 printf("fork returned %d %d\n",t1,t2); exit(0);&#125; 12345student@BUPTIA:~/fork$ ./fork11fork returned 1237 1238student@BUPTIA:~/fork$ fork returned 1237 0fork returned 0 1239 fork returned 0 0 （1）在多添加了一个fork()之后，其实一共产生了4个进程，分别是爷爷 - 爸爸/叔叔 - 你。具体流程参见代码注释。 （2）不妨想一想输出结果的四行分别对应哪个进程，我相信初次见面一定会发现诡异的地方的，欢迎讨论。 Hint：执行fork()时，并不是从#include处开始复制代码。详细的原因可在本页面某处找到:) （3）那怎么用两个fork()实现爷爷 - 爸爸 - 你，这样的流程来得到能直接链表串起来的三个进程啊？ 答案：加个判断，只让子进程产生子进程，代码如下：12345678910111213#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt; #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; pid_t t1,t2; t1=fork(); if(t1==0) t2=fork(); printf("fork returned %d %d\n",t1,t2); exit(0);&#125; fork2.c123456789101112131415#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main(void)&#123; pid_t t; printf("Original program, pid=%d\n", getpid()); t=fork(); if(t==0)&#123; printf("in the child process, pid=%d,ppid=%d\n",getpid(),getppid()); &#125;else&#123; printf("in parent, pid=%d,fork returned=%d\n",getpid(),t); &#125;&#125; 1234student@BUPTIA:~/fork$ ./fork2Original program, pid=1259in parent, pid=1259,fork returned=1260student@BUPTIA:~/fork$ in the child process, pid=1260,ppid=1 （1）为什么最后ppid=1？ 答：因为此时父进程的main函数退出了，父进程死亡了，子进程（pid=1260）没有了父进程，这是操作系统不允许的，所以系统把子进程的ppid置为1（INIT）。 exec1.c123456789101112131415#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main(void)&#123; char *arg[] = &#123;"/bin/ls",0&#125;; if(fork() == 0)&#123; printf("in child process: \n"); execv(arg[0], arg); printf("I will never be called \n"); &#125; printf("execution continues in parent process.\n");&#125; 123456student@BUPTIA:~/fork$ ./exec1execution continues in parent process.student@BUPTIA:~/fork$ in child process: exec1 exec2.c file.hole fork111 fork1.c lseek1 out.out readwrite2exec1.c exec3 fork1 fork111.c fork2 lseek1.c readwrite1 readwrite2.cexec2 exec3.c fork11 fork11.c fork2.c out1.out1 readwrite1.c （1）为什么子进程不执行printf(“I will never be called \n”);？ 答：execv()在创建进程时与fork()不同，执行了execv()的命令之后子进程就已经被替换，脱胎换骨不在继续往下走了。 （2）execv()的参数列表到底是怎样的？ 一开始看到代码里的参数，我是这样想的：第一个参数指明路径，第二个参数是要执行的命令和命令需要的参数，然后运行的时候，根据第一个参数找到命令所在的路径再执行，就像在cmd里运行javac，系统会先去环境变量里找到javac.exe所在的路径，在执行javac.exe那样，是不是看起来很有道理？？？然而并不是这样的。 我们找到execv()的函数原型： 1int execv(const char *progname, char *const argv[]); //#include &lt;unistd.h&gt; 事实是，第一个参数progname是被执行的命令（应用程序）的名字，且这个名字是需要带路径的，第二个参数argv是传递给命令（应用程序）的参数列表，为了保证这个参数列表数组的确是要执行的命令所需要的（我瞎猜的），我们必须把参数列表数组的第一个元素写成命令（应用程序）的名字。 所以其实Linux直接通过带路径的progname找到应用程序，在把argv的参数丢给应用程序，顺便检查一下argv里的第一个元素和应用程序的名字匹不匹配。 如果应用程序所需要的参数列表为空，那我们可以直接写execv(“/bin/ls”, NULL); lseek1.c123456789101112131415161718192021222324252627282930#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;char buf1[] = "abcdefghij";char buf2[] = "ABCDEFGHIJ";#define FILE_MODE 0777int main(void)&#123; int fd; if((fd=creat("file.hole",FILE_MODE)) &lt; 0) &#123; printf("creat error\n"); exit(1);&#125; if(write(fd,buf1,10)!=10)&#123; printf("buf1 write error\n"); exit(1);&#125; if(lseek(fd,40,SEEK_SET) == -1)&#123; printf("lseek error\n"); exit(1); &#125; if(write(fd,buf2,10)!=10)&#123; printf("buf2 write error\n"); exit(1);&#125; exit(0);&#125; 12345678abcdefghijABCDEFGHIJstudent@BUPTIA:~/fork$ ls -l file.hole-rw-r--r-- 1 student student 50 Mar 25 17:38 file.holestudent@BUPTIA:~/fork$ od -c file.hole0000000 a b c d e f g h i j \0 \0 \0 \0 \0 \00000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \00000040 \0 \0 \0 \0 \0 \0 \0 \0 A B C D E F G H0000060 I J0000062 （1）open函数： 1.int open(const char pathname, int flags);2.int open(const char pathname, int flags, mode_t mode); O_CREAT：如果文件不存在则创建文件，初次创建必须写；O_TRUNC：如果这个文件已经存在并且为可读可写/只写，这个文件内容将被清零； mode只有初次才用，用来规定权限。 （2）creat函数： int creat(const char *pathname, mode_t mode); creat() is equivalent to open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC. readwrite1.c1234567891011121314151617#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main(void)&#123; char quit = '.'; char buf[10]; int fd; if((fd = open("out.out",O_RDWR | O_CREAT,0)) == -1) printf("error in opening \n"); while(buf[0]!=quit)&#123; read(0,buf,1); write(fd,buf,1); write(1,buf,1); &#125; close(fd);&#125; （1）write() 函数定义：ssize_t write (int fd, const void * buf, size_t count); 函数说明：write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内。 返回值：如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。 NOTE：write()函数从buf写数据到fd中时，若buf中数据无法一次性读完，那么第二次读buf中数据时，其读位置指针（也就是第二个参数buf）不会自动移动，需要程序员编程控制，而不是简单的将buf首地址填入第二参数即可。如可按如下格式实现读位置移动：write(fp, p1+len, (strlen(p1)-len)。 这样write第二次循环时变会从p1+len处写数据到fp, 之后的也由此类推，直至(strlen(p1)-len变为0。 （2）read() 函数定义：ssize_t read(int fd, void * buf, size_t count); 函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。 返回值：返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则read()不会有作用并返回0。 NOTE：read时fd中的数据如果小于要读取的数据，就会引起阻塞。 （3）Linux所有的IO都是靠文件，所以用到了两个特殊的file descriptor 0 - 键盘 1 - 屏幕 signal1.c123456789101112131415#include&lt;signal.h&gt;void signalRoutine(int);int main(void)&#123; printf("signal processing demo program\n"); while(1)&#123; signal(SIGINT,signalRoutine); &#125;&#125;void signalRoutine(int dummy)&#123; printf("signalRoutine called [%d] \n",dummy); exit(0);&#125; 123student@BUPTIA:~/fork$ ./signal1signal processing demo program^CsignalRoutine called [2] （1）signal() 123#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); 第一个参数signum：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号； 第二个参数handler：描述了与信号关联的动作； 在本实例中测试signal interrupt靠Ctrl+C来实现，SIGINT对应2。 推荐阅读fork()函数详解execv()函数详解read() write()函数详解]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大三</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone换电池续命全攻略]]></title>
    <url>%2F2018%2F02%2F28%2FiPhone%E6%8D%A2%E7%94%B5%E6%B1%A0%E7%BB%AD%E5%91%BD%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[升级iOS时，为了防止设备意外关闭，如果iPhone安装的电池比较老旧，苹果会对处理器速度进行限制，从而导致iPhone性能下降。前不久，苹果承认iOS系统更新会降低旧版iPhone的运行速度，大批消费者谴责苹果之所以故意压低iPhone性能，其实是想引诱用户早早升级设备，苹果坚决否认，发表公开道歉信，并将更换手机电池的费用从79美元降至29美元（税后人民币217元）作为补偿措施。 我的手机是15年买的iPhone 6，买来近三年了，前两年电池寿命没到的时候确实从来没在冬天里被冻关机过，第三年冬天真的经常冻关机，我也没法判断是电池寿命到了还是因为升级了配置要求太高了达不到，果断决定吃了这波福利，并记录下全过程。 政策详情“直至 2018 年 12 月 31 日，对于符合条件的所有 iPhone 6 或更新机型，保外电池的服务费为 RMB 217。每部 iPhone 可能仅限接受一次定价为 RMB 217 的电池服务。” 所有价格均以人民币计算且含税，价格可能根据汇率浮动，我预约的时候还是RMB 218，第二天到场就变RMB 217了，开心~ 它这个“符合条件的所有 iPhone 6 或更新机型”指的具体是什么呢，我觉得就是： 1.机型：iPhone SE、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPhone 7、iPhone 7 Plus、iPhone 8、iPhone 8 Plus、iPhone X。 2.在国内购买，美版肯定是没戏的，毕竟消费者权益法不适用，国行肯定没问题啦，港版照理说也可以的，保险起见还是预约的时候提前打电话问问吧。 3.没有经过任何非官方授权的维修、更换。 预判到底该不该换电池，我们先做一个预判，我觉得主要可以从以下三方面判断电池是否需要更换，如果电池性能还不错的话，就没必要现在吃福利了，毕竟这个政策持续到今年年底；我在换电池的时候，旁边排队的大叔电池余量还85%呢，也跑来换电池，我觉得完全没必要还浪费时间浪费资源，他手机也就刚用一年。 电池寿命预判：网上说一般400次完全重放电后电池的容量会大幅度减少,待机时间缩短。官方没有明确表示过，我觉得对于苹果电池大概就是两年吧，毕竟前两年什么问题也没有，也没有遇到低温电池保护导致意外关机的情况。所以使用超过两年的朋友们，注意了啊~ 手机提示语：打开“设置-电池”，如果电池有问题，顶部会有一句很明显的提示语，大概说的是“您的电池可能需要维修”，然后外加一个了解详情的链接，这不就告诉你电池有问题了嘛；或者打开App Store，搜索“电池”，随便找一个能查看电池余量的应用下载下来，看看余量详情呗，我下的Battery Care，一看余量只有50%了，妥妥的撑不住了。 意外关机：如果你在生活中已经出现了手机明明有电，意外关机的情况，基本就要注意了。 当电池处于低电量状态，或化学年龄偏高，亦或置于低温环境下时，用户遇到意外关机的可能性更大。在极端情况下，关机会出现得更加频繁，因而导致设备变得不稳定或无法使用。 更多iPhone电池性能的信息，请点击： https://support.apple.com/zh-cn/ht208387 预约如果已经确定电池需要更换，下一步我们就得预约电池更换服务了，我了解的预约方式有两种： 线上：去官网预约，或者下载“Apple 支持”从app内预约 线下：上午十点，去直营店排队临时排号预约 官网预约（https://getsupport.apple.com/），或者app预约步骤都是一样的，选择：设备-主题(电池)-更换电池，之后选择自行送修，登陆Apple ID，填写个人信息，查找合适的维修地点(直营店或授权店)，预约Genius Bar成功~ 预约的时候特别注意，官网也会提醒：对于 iPhone 6 Plus，在送修以前，请提前致电确认电池有库存。 预约之后，贴心的苹果还会贴出来4条待办事项： 确保备齐相关文件 必须带身份证件前往，预约姓名必须与身份证姓名一致 携带购买凭证 请务必携带您的购买凭证前往 备份数据 请务必使用iCloud备份iPhone上的数据。检修设备时需要协助工作人员关闭“查找我的iPhone” 更新软件 许多问题都可以通过更新iPhone上的软件得到解决 我倒是老老实实按照要求做了，然而实际操作起来： 身份证是必须带的，取机的时候要用； 购买凭证，我好不容易翻出来了，然而全程并没有用到； 备份数据，倒不是维修会强行删数据，只是怕有意外所以要求你提前备份好； 更新，我一直老老实实该更新更新，我也不知道不更新会有啥后果。 更换流程大概是，到店 - 签到 - 排号等待接待 - 接待 - 维修 - 取机 我当时预约的是王府井直营店，到预约的时间了直奔二层Genius Bar找小哥哥输身份证号签到，签到之后就等叫号叫到我了，然后到了时间，接待员小姐姐把我领到角落那个专门接电池单的接待员那里，扒了手机壳，开始一分钟的连机检测，这个时候接待员会说：如果检测发现有其他地方的硬件也坏了，会联系您决定要不要维修。检测的时候接待员还真的特意观察了一下外观！！ 检测好了，留下锁屏密码，在单子上注明取机时间，我就和石榴小姐姐去逛街了。 到点去B1排队取机，也很快，交了单子，拿到手机，交费走人，石榴小姐姐试了一下，她说像新的一样，特别流畅，她也想换电池来了。 截至我写这篇文章的这24小时里，我的感受就是不卡了不降频了也不用担心在外边被冻关机了，充电宝都不用随身带了，20%的电撑了俩小时。 去之前我不确定取机时间，网上都说2-3小时，到场了跟接待员沟通了一下，店里每天接单数固定的，所以到底多久能取走不确定，排的早当天可取，排的晚单号只剩第二天的了就只能第二天取了。 我当时预约时间下午2：30，排到的取机时间是下午6：30，四个小时逛逛街就过去了，但我坐在那等了一会石榴小姐姐，在回过身来看到的单子就只剩第二天上午的取机时间了… 所以预约的越早，排到的取机时间越早，如果预约的时间比较晚，那还得第二天在跑一趟，还不如直接预约第二天上午的时间呢。本来我想着带个备用手机先插卡应付一下，但是维修过程中，工作人员为了防止SIM卡被客户弄丢，会把取下来的SIM卡用胶带粘附在Genius Bar服务单（也就是取机凭证）上。 P.S. 有个接待员跟我说最能保证当天拿到机子的方法就是上午十点来线程排临时号预约。 大概流程就是这样，本文献给大冷天背着三本书，收到微信消息马上赶过来说要学习结果陪我这个失联女孩逛了一下午街的石榴里美。]]></content>
      <categories>
        <category>Living</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法基础与进阶]]></title>
    <url>%2F2018%2F02%2F07%2FMarkdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Hexo写文章确实很好上手，但在新手(嗯，就是我)写文章的时候总会遇到一些特殊格式，或者引用资源之类的，让我拿着Notepad不知所措，比如一开始我po的几篇作业的题目中涉及一些带指数的公式之类的，我只能瑟瑟发抖拿^处理，那个时候遇见图片我就直接注释“图片参见课件”…… 昨天学了怎么插图片，但调整图片相关的属性还没写，打算一会更新到那篇教程的进阶里…… 基础篇在一开始看完官方写作文档Hexo Writing里最基础的内容 + hello world之后，我就着急上手了，所以在前几篇文章里，我只实际应用了以下几个格式： 1.大标题： ## heading2.小标题： ### heading3.普通文本：plain text4.超链接： [text](url)5.代码块： &#96;&#96;&#96;//some code here&#96;&#96;&#96; 然而这在实际应用中肯定是不够的啊！所以今天来学习一下Markdown语法，相信写完这篇教程我就可以变身小达人了~进阶篇Hexo的文章是靠.md文件写入的，也就是Markdown，Markdown是一种标记语言（这是废话，你从名字就能看出来）说到这很多人会想起HTML(HyperText Mark-up Language),这大概是大家最先接触的一门标签/标记语言，简单说就是靠一堆标签来布置网页上的内容，之后我们又学了CSS(Cascading Style Sheets),也就是样式表，这货的出现是在HTML之后，为了补充更强大更复杂的样式功能，也为了把网页中的内容和样式分开来，可以看出来他们俩在一起越来越复杂化了；所以又出现了Markdown（我猜这个名字就是为了和HTML的Markup做区分来的），这是一个清爽简单版，所见即所得的标记语言，没有复杂的标签和属性，只需要在文本上加几个符号之类的，而各位用Hexo的很重要的一个原因就是简洁、方便、流畅，那么为啥Hexo要用Markdown也就可想而知啦（当然啦Markdown也是兼容HTML的，所以你在文章里用标签也没问题）。在想想Servlet和JSP的关系，哎呀这不就是HTML和Markdown的关系吗！为了化繁为简，专门给我这种懒蛋+小白设计的。不信你看，你写好的文章部署完了之后，打开页面，右键查看源代码，不还是HTML吗？！哈哈哈 “Markdown 从来都不是用来替代 HTML的，更不是用于前端开发、写完整页面的。 arkdown的设计目的是方便写作的时候，标记格式、同时使标记格式后的纯文本，比起 HTML 源码，更有可读性。 arkdown 的呈现需要解析成HTML, 而其支持的 HTML 标记也只是一部分。从这个角度看， Markdown 可算是 HTML 的一个简化了标记形式的子集。” 标题 Markdown支持共六级标题，语法如下：123# 第一级标题## 第二级标题###### 第六级标题 强调12345*这些文字会生成&lt;em&gt;的效果*_这些文字会生成&lt;u&gt;的效果_**这些文字会生成&lt;strong&gt;效果**__这些文字会生成&lt;strong&gt;的效果__ 效果如下：这些文字会生成&lt;em&gt;的效果这些文字会生成&lt;u&gt;的效果这些文字会生成&lt;strong&gt;效果这些文字会生成&lt;strong&gt;的效果 换行四个及以上的空格加回车。（这个还真不如直接用HTML简单） 无序列表1234567* 项目一 无序列表 * 项目二 * 项目二的子项目一 无序列表 * 项目二的子项目二即：*+空格+项目TAB+*+空格+子项目 效果如下： 项目一 无序列表 项目二 项目二的子项目一 项目二的子项目二 有序列表语法如下：123456781. 项目一 有序列表 2. 项目二 3. 项目三 1. 项目三的子项目一 2. 项目三的子项目二即：数字+.+空格+项目TAB+数字+.+空格+子项目 效果如下： 项目一 有序列表 项目二 项目三 项目三的子项目一 项目三的子项目二 任务列表语法如下（中括号内为字母x）：12- [ ] 任务一 未做任务 - [x] 任务二 已做任务 效果如下： 任务一 未做任务 任务二 已做任务 图片语法如下：1![title text](url) 关于插入图片的详情请查看另一篇文章：如何在.md文件中插入图片 链接语法如下：123456文本链接：[text](url)自动生成链接：&lt;url&gt;例：email &lt;example@example.com&gt;[GitHub](http://github.com)自动生成连接 &lt;http://www.github.com/&gt; 效果如下：email &#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;GitHub自动生成连接 http://www.github.com/ 引用语法如下：12&gt; 第一行引用文字&gt; 第二行引用文字 效果如下： 第一行引用文字第二行引用文字 行内代码语法如下：1`code here` 代码块语法如下： &#96;&#96;&#96;+language //some code here &#96;&#96;&#96; 效果：就是以上所有的语法块~ 1printf("hello world"); 流程图 需要先安装相关插件 1npm install --save hexo-filter-flowchart 语法如下： &#96;&#96;&#96;flow st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&#96;&#96;&#96; 效果如下： 表格语法如下：1234第一格表头 | 第二格表头--------- | -------------内容单元格 第一列第一格 | 内容单元格第二列第一格内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 删除线语法如下：1~~需要加删除线的内容~~ 效果如下：需要加删除线的内容 分割线语法如下：123********- - - 效果如下： 简单公式需要先打开主题的配置文件，修改相关项：12mathjax: enable: true 语法如下：1$$E=mc^2$$ 效果如下：$$E=mc^2$$ 脚注需要先安装相关插件1npm install hexo-footnotes --save 打开主题的配置文件，启用插件：12plugins: - hexo-footnotes 语法如下：12345678910basic footnote[^1]here is an inline footnote[^2](inline footnote)and another one[^3]and another one[^4][^1]: basic footnote content[^3]: paragraphfootnotecontent[^4]: footnote content with some [markdown](https://en.wikipedia.org/wiki/Markdown) 效果如下：basic footnote1here is an inline footnote2and another one3and another one4 好啦，大概就是这些。 后续1.实际上学完这些之后，我还是下载了三个Markdown编辑器……分别是： Cmd Markdown两侧对照式，一侧编辑区，一侧效果展示，跟Dreamweaver是的，看起来还不错。Typora界面非常美观，所见即所得，输入完（也可以偷懒点选项键）就会自动变成想要的格式，但是格式一复杂很容易出错，而且它自动乱加格式，查了一下好像不光我有这个问题。MarkDownEditor听说是很官方的编辑器，可是外观像Win 8似的，看了一下功能和Cmd Markdown一样，就没尝试…… 2.我在整理这篇教程的时候，那些语法是靠代码块来注释转义的，毕竟Markdown没有转义这么一说，然而我发现有一些插件支持的markdown语法太强了，强到就算考代码块注释都会被识别出来显示出格式，比如脚注的语法，就算注释进代码块，还是会显示出来，最后发现了解决办法是给代码块指定一个语言，比如我指定的语言是C，它就按照C语言的标准解析出各部分的颜色，虽然语法莫名其妙变得花花绿绿，但总算不会出现代码块里搀着显示出来的语法格式的问题了。 3.看了一些文档，原来Markdown的格式也可以自己改代码设定的，看了一位前辈改的还蛮好看蛮有风格，我这种又懒又强迫症又容易一改改几天的人就不尝试了，大家可以改成自己的风格玩玩~ st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);1.basic footnote content ↩2.inline footnote ↩3.paragraphfootnotecontent ↩4.footnote content with some markdown ↩]]></content>
      <categories>
        <category>Posting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在文章中(.md)插入图片]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A6%82%E4%BD%95%E5%9C%A8-md%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[起因刚进hexo的坑不久，我写post的方式完全就是最基础的：1hexo new post title 然后在_posts文件夹右键拿Notepad++打开.md文件，然后开始写呀写，一开始没注意到什么问题，主要我自己也没学过Markdown，也没仔细看文档（我只看了基础篇），所以就遇到了一个大问题，写文章的时候不会插图片怎么办？？？于是今天就来学习一下到底如何在文章里插图片，并写下这个教程。 经过1.首先你要打开网站的_config.yml，搜索post_asset_folder这一项（你也可以自己找到这项，反正我眼睛不好得靠Notepad的搜索）。修改这一项的参数，把预置的false改成true。1post_asset_folder: true 这一项的作用就是让hexo在你写new post的时候自动建立一个与文章同名的文件夹，用来放置与该文章相关的所有资源。 2.在网站目录下打开Git Bash，执行以下语句，安装相关插件。1npm install https://github.com/CodeFalling/hexo-asset-image --save 然后等待安装，安装完成后，会输出：12345npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-asset-image@0.0.3added 6 packages in 173.081s 最后两行表示插件安装成功，@后边应该是版本号。 3.之后在用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。结构如下：xxxx├── 图片名.jpg├── 图片名2.jpg└── 图片名3.jpgxxxx.md 4.在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照Markdown的格式插入图片即可，其中[]空着不写则没有图片标题。![你想输入的标题](xxxx/图片名.jpg) 5.最后检查一下，hexo g或者hexo generate生成页面后，进入public\2018\2\6\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2018/2/6/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 结果以上就是我在.md中输入![Cat](/2018/02/06/如何在-md文章中插入图片/1202495.png)出现的效果啦。 后续查看官方文档，找到了引用文章资源的标签代码，再来用官方的标签插件测试一下： 1234//引用文章的资源。&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 以上是我在.md文件中写入下列代码的效果1&#123;% asset_img 1202495.png This is an example image %&#125; 另外我找到了一个比Notepad++方便很多的Markdown编辑器，叫Cmd Markdown，看起来非常好用，下次写作试一下~ 进阶学会插入图片之后，接下来要解决的一个问题是图片的尺寸，上文中可以看到图片整个填充到了博文中，并不是原始尺寸。（本来只是一个很小的icon），要解决这个问题，我们就要联系到Markdown语法基础与进阶那篇文章，在那里我们说过了，Markdown还是支持html的，所以我们可以利用html标签来插入图片顺便更改大小。 以上是我在.md写入下列代码的效果： 1&lt;img src=&quot;/2018/02/06/如何在-md文章中插入图片/1202495.png&quot; style=&quot;width: 20%;&quot;&gt;]]></content>
      <categories>
        <category>Posting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二下 数据结构（五）]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%BA%8C%E4%B8%8B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[适用于电商专业大二年级下学期，数据结构专业选修课，不是物联网同学大二上的数据结构哦。年代久远，仅供参考。 目标：掌握排序和折半查找算法。内容：查找表是学生记录的集合，记录由如下数据项组成： （学号，姓名，数据结构课程成绩）(1)用冒泡排序方法对查找表按照成绩非递减排序(2)基于折半查找的方法对指定成绩的记录查找，输出查找成功的记录在有序序列中的位序及其完整记录内容或者说明查找失败。 测试实例：(1) 成绩排列为{50 94 65 97 78 81 83 76 88 92 78}，对应的学号和姓名项自行拟值(2) 查找成绩分别为 78和89 的记录 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define LIST_INIT_SIZE 100#define INCREMENT_SIZE 10struct stu//create the array of structure and initialize the data.&#123; int num; char name[20]; int score;&#125;student[]=&#123;&#123;0001,"Lydia",50&#125;,&#123;0002,"Mary",94&#125;,&#123;0003,"Mark",65&#125;,&#123;0004,"Santanico",97&#125;,&#123;0005,"Jack",78&#125;,&#123;0006,"Rose",81&#125;,&#123;0007,"Kenna",83&#125;,&#123;0015,"Henry",76&#125;,&#123;0015,"Katherine",88&#125;,&#123;0010,"Claude",92&#125;,&#123;0011,"Leith",78&#125;&#125;;typedef struct SSTable&#123; stu *elem; int length; int tablesize;&#125;; SSTable T;int InitTable(SSTable &amp;T)//initialize the sequence table&#123; T.elem=(stu *)malloc(LIST_INIT_SIZE*sizeof(stu)); if(!T.elem)return -2; T.length=0; T.tablesize=LIST_INIT_SIZE; return 1;&#125;void InputTable(SSTable &amp;T)&#123; printf("Before Sorting, data in the table are as followed：\nNO. Name Score of DS：\n"); for(int i=0;i&lt;=10;i++)&#123; T.elem[i+1]=student[i];//assign the data from the array to the table T.length++; printf("%-10d %-10s %-10d\n",T.elem[i+1].num,T.elem[i+1].name,T.elem[i+1].score); &#125;&#125;void BubbleSort(SSTable &amp;T)&#123; int i ,j; stu temp; int sorted=0; for(i = 0; i &lt; T.length &amp;&amp; ( !sorted); i++)&#123;//sorting the data in non-decreasing order sorted = 1; for(j = 1; j &lt; T.length-i; j++) &#123; if(T.elem[j].score&gt;T.elem[j+1].score) &#123; temp=T.elem[j]; T.elem[j]=T.elem[j+1]; T.elem[j+1]=temp; sorted=0; &#125; &#125; &#125; stu *k;//print out the data after sorting printf("-------------------------------------------------------\nAfter Bubble Sorting, data in the table are as followed：\nNO. Name Score of DS：\n"); for(k = T.elem + 1; k &lt;= T.elem+T.length; k++) printf("%-10d %-10s %-10d\n",k-&gt;num,k-&gt;name,k-&gt;score);&#125;int result;int Search_Bin(SSTable T,int key)//binary search funtion&#123; int low = 1,high = T.length;// put initial range values while ( low &lt;= high ) &#123; int mid = ( low + high )/2; if (key == T.elem[mid].score) &#123; //print out the data for corresponding score printf("-------------------------------------------------------\nSearched Successfully! Data are as followed:\n"); printf("NO. Name Score of DS\n"); printf("%-10d %-10s %-10d\n",T.elem[mid].num,T.elem[mid].name,T.elem[mid].score); result = mid; int k; for (k = 1; T.elem[mid - k].score &gt;= T.elem[mid].score; k++)&#123; printf("NO. Name Score of DS\n"); printf("%-10d %-10s %-10d\n",T.elem[mid - k].num,T.elem[mid - k].name,T.elem[mid - k].score); &#125; for (k = 1; T.elem[mid + k].score &lt;= T.elem[mid].score; k++)&#123; printf("NO. Name Score of DS\n"); printf("%-10d %-10s %-10d\n",T.elem[mid + k].num,T.elem[mid + k].name,T.elem[mid + k].score); &#125; return result; &#125; else &#123; if ( key &lt; T.elem[mid].score) high = mid - 1; else low = mid + 1; &#125; &#125; result = -1; if(result==-1)//print out that no such record is in the table printf("\nSearching failed, no such record in the table!\n\n"); return result;&#125;int main()&#123; int i; InitTable(T); InputTable(T); BubbleSort(T); int key[2];//declare the array of keys to be searched for(int i=0;i&lt;=1;i++)&#123; printf("\nPlease input the score of (%d) to be searched:\n",i+1); scanf("%d", &amp;key[i]); Search_Bin(T, key[i]); &#125; system("pause"); &#125; 日常帮写第二份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define LIST_INIT_SIZE 100#define INCREMENT_SIZE 10struct stu&#123; int num; char name[20]; int score;&#125;; stu student[11]=&#123;&#123;1110,"晨晨",50&#125;,&#123;1111,"倩倩",94&#125;,&#123;1112,"瑶瑶",65&#125;,&#123;1113,"事事",97&#125;,&#123;1114,"依依",78&#125;,&#123;1115,"格格",81&#125;,&#123;1116,"嗒嗒",83&#125;,&#123;1117,"帅帅",76&#125;,&#123;1118,"咯咯",88&#125;,&#123;1119,"噢噢",92&#125;,&#123;1120,"娅娅",78&#125;&#125;;//创建结构体数组typedef struct SSTable&#123; stu *elem; int length; int tablesize;&#125;; SSTable List;int result;int InitTable(SSTable &amp;T)//生成顺序表 &#123; T.elem=(stu *)malloc(LIST_INIT_SIZE*sizeof(stu)); if(!T.elem)return -2; T.length=0; T.tablesize=LIST_INIT_SIZE; return 1;&#125;void InputTable(SSTable &amp;T)&#123; printf("表中数据如下：\n学号 姓名 数据结构成绩：\n"); for(int i=0;i&lt;=10;i++)&#123; T.elem[i+1].num=student[i].num;//把结构体数组中的数据录入到Table中 strcpy(T.elem[i+1].name,student[i].name); T.elem[i+1].score=student[i].score; T.length++; printf("%-10d %-10s %-10d\n",T.elem[i+1].num,T.elem[i+1].name,T.elem[i+1].score);//并打印出table中的数据 &#125;&#125;void OutputTable(SSTable T)&#123; stu *i; printf("表中数据如下：\n学号 姓名 数据结构成绩：\n"); for(i = T.elem + 1; i &lt;= T.elem+T.length; i++) printf("%-10d %-10s %-10d\n",i-&gt;num,i-&gt;name,i-&gt;score);&#125;void BubbleSort(SSTable &amp;T)&#123; int i ,j; stu temp; int sorted=0; for(i = 0; i &lt; T.length &amp;&amp; ( !sorted); i++)&#123; sorted = 1; for(j = 1; j &lt; T.length-i; j++) &#123; if(T.elem[j].score&gt;T.elem[j+1].score) &#123; temp=T.elem[j]; T.elem[j]=T.elem[j+1]; T.elem[j+1]=temp; sorted=0; &#125; &#125; &#125;&#125;int Search_Bin(SSTable T,int key)&#123; int low = 1,high = T.length;// 置区间初值 while ( low &lt;= high ) &#123; int mid = ( low + high )/2; if (key == T.elem[mid].score) &#123; //打印对应成绩的信息 printf("查找成功！信息如下:\n"); printf("学号 姓名 数据结构成绩：\n"); printf("%-10d %-10s %-10d\n",T.elem[mid].num,T.elem[mid].name,T.elem[mid].score); result = mid; int k; for (k = 1; T.elem[mid - k].score &gt;= T.elem[mid].score; k++)&#123; printf("学号 姓名 数据结构成绩：\n"); printf("%-10d %-10s %-10d\n",T.elem[mid - k].num,T.elem[mid - k].name,T.elem[mid - k].score); &#125; for (k = 1; T.elem[mid + k].score &lt;= T.elem[mid].score; k++)&#123; printf("学号 姓名 数据结构成绩：\n"); printf("%-10d %-10s %-10d\n",T.elem[mid + k].num,T.elem[mid + k].name,T.elem[mid + k].score); &#125; return result; &#125; // 找到待查元素的处理方式 else &#123; if ( key &lt; T.elem[mid].score) high = mid - 1; // 继续在前半区间进行查找 else low = mid + 1; // 继续在后半区间进行查找 &#125; &#125; result = -1; return result;//在顺序表中找不到待查元素的处理方式 &#125;int main()&#123; int i; InitTable(List); InputTable(List); BubbleSort(List); printf("\n冒泡排序方法对查找表按照成绩非递减排序后:\n"); OutputTable(List); int k1, k2;//声明待查找的两个数据的key printf("\n请输入待查找数据(1)的成绩:\n"); scanf("%d", &amp;k1); Search_Bin(List, k1); if(result==-1) printf("查找失败！"); printf("\n\n请输入待查找数据(2)的成绩:\n"); scanf("%d", &amp;k2); Search_Bin(List, k2); if(result==-1) printf("查找失败！"); system("pause"); &#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二下 数据结构（四）]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%BA%8C%E4%B8%8B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[适用于电商专业大二年级下学期，数据结构专业选修课，不是物联网同学大二上的数据结构哦。年代久远，仅供参考。 目标：二叉树及其应用。内容：(1) 用先序递归过程建立二叉树 (存储结构：二叉链表)输入数据按先序遍历所得序列输入，当某结点左子树或右子树为空时，输入‘’号，如输入abcde*得到的二叉树为：（图片如课件）(2) 计算二叉树中叶子结点的数目。 代码这篇因为我日常得写两份，所以自己的那份干脆用c++，给别人的那份是c，所以建议直接看第二份。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt; using namespace std; typedef struct node//建立二叉链表的储存结构 &#123; struct node *leftChild; struct node *rightChild; char data; &#125;BiTreeNode, *BiTree; void createBiTree(BiTree &amp;T) &#123; char c; cin &gt;&gt; c; //扫描得到字符 if('*' == c) //如果字符为*，则根节点为空 T = NULL; else &#123; T = new BiTreeNode; //否则建立根节点 T-&gt;data = c; createBiTree(T-&gt;leftChild); createBiTree(T-&gt;rightChild); &#125; &#125; //先序遍历 void preOrderTraverse(BiTree T) &#123; if(T) &#123; cout &lt;&lt; T-&gt;data &lt;&lt; " "; preOrderTraverse(T-&gt;leftChild); preOrderTraverse(T-&gt;rightChild); &#125; &#125; // 中序遍历 void inOrderTraverse(BiTree T) &#123; if(T) &#123; inOrderTraverse(T-&gt;leftChild); cout &lt;&lt; T-&gt;data &lt;&lt; " "; inOrderTraverse(T-&gt;rightChild); &#125; &#125; // 后序遍历 void postOrderTraverse(BiTree T) &#123; if(T) &#123; postOrderTraverse(T-&gt;leftChild); postOrderTraverse(T-&gt;rightChild); cout &lt;&lt;T-&gt;data &lt;&lt; " "; &#125; &#125; int getLeafNode(BiTree T) &#123; if(NULL == T) return 0; if(NULL == T-&gt;leftChild &amp;&amp; NULL == T-&gt;rightChild) return 1; return getLeafNode(T-&gt;leftChild) + getLeafNode(T-&gt;rightChild); &#125; int main() &#123; BiTree T; cout &lt;&lt;"Please input the data of the BiTree in the preorder. Type in \"*\" to represent the NULL."&lt;&lt; endl; createBiTree(T); cout &lt;&lt; "\nPreorder:" &lt;&lt; endl; preOrderTraverse(T); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "Inorder:" &lt;&lt; endl; inOrderTraverse(T); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "Postorder:" &lt;&lt; endl; postOrderTraverse(T); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "The number of LeafNodes is:" &lt;&lt; endl; cout &lt;&lt; getLeafNode(T) &lt;&lt; endl; return 0; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt; typedef struct BiTNode&#123;//建立二叉链表的储存结构 char data; struct BiTNode *lchild,*rchild;&#125;BiTNode, * BiTree;int count=0;void CreateBiTree(BiTree &amp;T) &#123; char ch; scanf("%c",&amp;ch);//扫描得到字符 if(ch=='*') T=NULL;//如果字符为空，则根节点为空 else &#123; if (!(T=(BiTNode *)malloc(sizeof(BiTNode))))//否则建立根节点 exit(-1); T-&gt;data = ch;//根节点数据域 CreateBiTree(T-&gt;lchild);//构造左子树 CreateBiTree(T-&gt;rchild);//构造右子树 &#125; &#125; void PreOrder(BiTree &amp;T)&#123; //先序遍历 if(T != NULL)&#123; printf("%c",T-&gt;data); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125;void CountLeaf(BiTree T,int&amp; count)//累加和存储于变量count中，其初值为0 &#123; if(T)//二叉树T如果为空，则什么都不做；不为空时往下执行 &#123; if((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))//如果二叉树左子树和右子树皆为空，说明该二叉树根节点为叶子节点，count加1。 count++; CountLeaf(T-&gt;lchild,count);//遍历左子树叶子节点个数 CountLeaf(T-&gt;rchild,count);//遍历右子树叶子节点个数 &#125; &#125; int main()&#123; BiTree T; printf("Please type in the BiTree data in preorder, type in * to represent NULL:\n"); CreateBiTree(T); printf("PreOrder:"); PreOrder(T); CountLeaf(T,count); printf("\nThe number of leafnodes is: %d\n",count); system("pause");&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二下 数据结构（三）]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%BA%8C%E4%B8%8B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[适用于电商专业大二年级下学期，数据结构专业选修课，不是物联网同学大二上的数据结构哦。年代久远，仅供参考。 目标：线性表在链式存储结构的实现。内容：已知某线性表中的数据元素由三个数据项（学号、姓名、成绩）组成，且数据元素按照学号递增有序，表长为n。选择带头结点的单链表作为存储结构。设计并实现如下算法：（1） n个数据元素作为初始数据，置入相应的存储结构中。(测试时至少10个数据元素），输出线性表中各数据元素。（2）将新的数据元素x插入到线性表的适当位置上，以保持该表的有序性，输出线性表中各数据元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAX 10 //链表中数据的最大个数 struct stu&#123; int num; char name[20]; float score;&#125;student,temp;//创建结构体数组 typedef struct LNode&#123;//定义单链表的存储结构 stu student; struct LNode * next;&#125;LNode,* LinkList;LNode *p;void Create_LinkList(LinkList &amp;L,int n)&#123;//逆向插法建立单链表 L=(LinkList)malloc(sizeof(LNode)); if(!L)&#123; printf("Failed to create the LinkList！\n"); exit(-1); &#125; L-&gt;next=NULL;//建立一个带头结点的单链表 for(int i=n;i&gt;0;i--)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 printf("Please input the data(number/name/score) of NO.%d student:",n-i+1); scanf("%d%s%f",&amp;p-&gt;student.num,p-&gt;student.name,&amp;p-&gt;student.score); p-&gt;next=L-&gt;next; L-&gt;next=p; &#125; &#125;void Insert(LinkList L)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 printf("Please input the data(number/name/score) to be inserted:"); scanf("%d%s%f",&amp;p-&gt;student.num,p-&gt;student.name,&amp;p-&gt;student.score); p-&gt;next=L-&gt;next; L-&gt;next=p;&#125;void Display(LinkList L)&#123; printf("\nThe data in storage are：\nNO. NAME SCORE\n"); LNode *s; s=L; while(s-&gt;next!=NULL)&#123; s=s-&gt;next; printf(" %d %-s %-.1f\n",s-&gt;student.num,s-&gt;student.name,s-&gt;student.score); &#125; printf("\n"); &#125; void LinkList_Sort(LinkList L)&#123; LNode *p, *q, *min; p=L-&gt;next; while(p != NULL)&#123; min = p; q = p-&gt;next; while (q != NULL)&#123; if ((min-&gt;student.num) &gt; (q-&gt;student.num)) min = q; q = q-&gt;next; &#125; if (min != p)&#123; temp.num = min-&gt;student.num; strcpy(temp.name,min-&gt;student.name); temp.score=min-&gt;student.score; min-&gt;student.num = p-&gt;student.num; strcpy(min-&gt;student.name ,p-&gt;student.name); min-&gt;student.score = p-&gt;student.score; p-&gt;student.num = temp.num; strcpy(p-&gt;student.name , temp.name); p-&gt;student.score = temp.score; &#125; p = p-&gt;next; &#125;&#125;int main()&#123; LinkList L; Create_LinkList(L,MAX); Display(L); Insert(L); LinkList_Sort(L); Display(L); system("pause"); &#125; 日常帮写第二份12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define LIST_INIT_SIZE 100struct students&#123; int num; char name[30]; float score;&#125;student,temp;typedef struct LNode&#123; students student; struct LNode * next;&#125;LNode,* LinkList;LinkList L;LNode *p;int CreateLinkList(LinkList &amp;L,int n)&#123; L=(LinkList)malloc(sizeof(LNode)); if(!L)&#123; printf("表头结点开辟失败！\n"); exit(-1); &#125; L-&gt;next=NULL; for(int i=n;i&gt;0;i--)&#123; p=(LinkList)malloc(sizeof(LNode)); printf("请输入第%d位学生信息学号/姓名/成绩:",n-i+1); scanf("%d%s%f",&amp;p-&gt;student.num,p-&gt;student.name,&amp;p-&gt;student.score); p-&gt;next=L-&gt;next; L-&gt;next=p; &#125; return 0;&#125;int InsertLinkList(LinkList L)&#123; p=(LinkList)malloc(sizeof(LNode)); printf("请输入待插入的数据（学号/姓名/成绩）:"); scanf("%d%s%f",&amp;p-&gt;student.num,p-&gt;student.name,&amp;p-&gt;student.score); p-&gt;next=L-&gt;next; L-&gt;next=p; return 0;&#125;int PrintLinkList(LinkList L)&#123; printf("\n单链表中的数据为：\n学号 姓名 成绩\n"); LNode *s; s=L; while(s-&gt;next!=NULL)&#123; s=s-&gt;next; printf(" %d %-s %-.1f\n",s-&gt;student.num,s-&gt;student.name,s-&gt;student.score); &#125; printf("\n"); return 0;&#125; int LinkListSort(LinkList L)&#123; LNode *p, *q, *min; p=L-&gt;next; while(p != NULL)&#123; min = p; q = p-&gt;next; while (q != NULL)&#123; if ((min-&gt;student.num) &gt; (q-&gt;student.num)) min = q; q = q-&gt;next; &#125; if (min != p)&#123; temp.num = min-&gt;student.num; strcpy(temp.name,min-&gt;student.name); temp.score=min-&gt;student.score; min-&gt;student.num = p-&gt;student.num; strcpy(min-&gt;student.name ,p-&gt;student.name); min-&gt;student.score = p-&gt;student.score; p-&gt;student.num = temp.num; strcpy(p-&gt;student.name , temp.name); p-&gt;student.score = temp.score; &#125; p = p-&gt;next; &#125; return 0;&#125;int main()&#123; CreateLinkList(L,10); InsertLinkList(L); LinkListSort(L); PrintLinkList(L); return 0;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二下 数据结构（二）]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%BA%8C%E4%B8%8B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[适用于电商专业大二年级下学期，数据结构专业选修课，不是物联网同学大二上的数据结构哦。年代久远，仅供参考。 目标：线性表在顺序存储结构的实现。内容：已知某线性表中的数据元素由三个数据项（学号、姓名、成绩）组成，且数据元素按照学号递增有序，表长为n。选择顺序表 作为存储结构。设计并实现如下算法：（1）n个数据元素作为初始数据，置入相应的存储结构中。(测试时至少10个数据元素），输出线性表中各数据元素。（2）将新的数据元素x插入到线性表的适当位置上，以保持该表的有序性，输出线性表中各数据元素。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define LIST_INIT_SIZE 100#define MAX 10 //顺序表数据最大个数 struct stu&#123; int num; char name[20]; float score;&#125;student[MAX],temp;//创建结构体数组 typedef struct&#123;//定义线性表的动态分配顺序存储结构 stu *elem; int length; int listsize;&#125;Sqlist;int InsertList(Sqlist &amp;L)&#123;//插入数据 int i,insert_space; scanf("%d%s%f",&amp;temp.num,temp.name,&amp;temp.score); for(i=0;i&lt;L.length;i++)&#123; if(temp.num&lt;L.elem[i].num)&#123; break; &#125; &#125; insert_space=i; for(i=L.length-1;i&gt;=insert_space;i--)&#123; L.elem[i+1].num=L.elem[i].num; strcpy(L.elem[i+1].name,L.elem[i].name); L.elem[i+1].score=L.elem[i].score; &#125; L.elem[insert_space].num=temp.num; strcpy(L.elem[insert_space].name,temp.name); L.elem[insert_space].score=temp.score; L.length++; return 0;&#125;int InitList_Sq(Sqlist &amp;L)&#123; //构造一个空的线性表L L.elem=(stu *)malloc(LIST_INIT_SIZE*sizeof(stu)); if(L.elem==NULL) &#123; printf("Allocation failed!\n"); exit(0); &#125; printf("Allocation successed!\n"); L.length=0; L.listsize=LIST_INIT_SIZE; //录入原始信息 int insert_space,j,i=0; for(j=0;j&lt;MAX;j++)&#123; printf("Please input the data(number/name/score) of NO.%d student:",j+1); InsertList(L); &#125; return 0;&#125;int DisplayList(Sqlist &amp;L)&#123;//显示线性表中的所有数据 printf("\n线性表中的数据如下：\n学号 姓名 成绩\n"); for(int i=0;i&lt;L.length;i++)&#123; printf(" %d %-s %-.1f\n",L.elem[i].num,L.elem[i].name,L.elem[i].score); &#125; return 0; &#125;main()&#123; Sqlist L; //声明线性表L InitList_Sq(L); DisplayList(L); printf("\nPlease input the data X to be inserted(number/name/score):"); InsertList(L); printf("\n*******插入新数据X后*******"); DisplayList(L); system("pause"); &#125; 日常帮写第二份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define LIST_INIT_SIZE 100#define MAX 10 struct stu&#123; int num; char name[20]; float score;&#125;student[MAX],temp;typedef struct&#123; stu *elem; int length; int listsize;&#125;Sqlist;int InitList_Sq(Sqlist &amp;L)&#123; //构造一个空的线性表L L.elem=(stu *)malloc(LIST_INIT_SIZE*sizeof(stu)); if(L.elem==NULL) &#123; printf("内存分配成功！\n"); exit(0); &#125; printf("内存分配失败！\n"); L.length=0; L.listsize=LIST_INIT_SIZE; int insert_space,j,i=0; for(i=0;i&lt;MAX;i++)&#123; printf("请输入第%d位学生信息学号/姓名/成绩）:",i+1); scanf("%d%s%f",&amp;temp.num,temp.name,&amp;temp.score); for(j=0;j&lt;L.length;j++) &#123; if(temp.num&lt;L.elem[j].num) &#123; break; &#125; &#125; insert_space=j; for(j=L.length-1;j&gt;=insert_space;j--) &#123; L.elem[j+1].num=L.elem[j].num; strcpy(L.elem[j+1].name,L.elem[j].name); L.elem[j+1].score=L.elem[j].score; &#125; L.elem[insert_space].num=temp.num; strcpy(L.elem[insert_space].name,temp.name); L.elem[insert_space].score=temp.score; L.length++; &#125; return 0;&#125;int InsertList(Sqlist &amp;L)&#123; int i,insert_space; printf("\n请输入待插入的数据（学号/姓名/成绩）:"); scanf("%d%s%f",&amp;temp.num,temp.name,&amp;temp.score); for(i=0;i&lt;L.length;i++) &#123; if(temp.num&lt;L.elem[i].num) &#123; break; &#125; &#125; insert_space=i; for(i=L.length-1;i&gt;=insert_space;i--) &#123; L.elem[i+1].num=L.elem[i].num; strcpy(L.elem[i+1].name,L.elem[i].name); L.elem[i+1].score=L.elem[i].score; &#125; L.elem[insert_space].num=temp.num; strcpy(L.elem[insert_space].name,temp.name); L.elem[insert_space].score=temp.score; L.length++; return 0;&#125;int DisplayList(Sqlist &amp;L)&#123; printf("\n线性表中的数据如下：\n学号 姓名 成绩\n"); for(int i=0;i&lt;L.length;i++)&#123; printf(" %d %-s %-.1f\n",L.elem[i].num,L.elem[i].name,L.elem[i].score); &#125; return 0; &#125;main()&#123; Sqlist List; InitList_Sq(List); DisplayList(List); InsertList(List); DisplayList(List); return 0;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二下 数据结构（一）]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%BA%8C%E4%B8%8B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[适用于电商专业大二年级下学期，数据结构专业选修课，不是物联网同学大二上的数据结构哦。年代久远，仅供参考。 目标：复习C语言的相关知识：（1）数组（顺序存储方法）（2）结构（构造多数据项的数据元素类型） 内容：（1）定义student[n]数组，数组元素为（学号、姓名、成绩），n取值10。（2）向数组中读入原始数据，其中有重复学号的数据，输出原始的数组数据。（3）删除有重复学号的数据（保留第一个），输出处理后的数组数据。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;#include&lt;string.h&gt;void timeclock();int main()&#123; int n = 10; struct stu &#123; int num; char name[20]; float score; &#125;student[n];//创建结构体数组 timeclock(); //加载系统时间 for(int i=0;i&lt;n;i++) &#123; printf("请输入第%d名同学的个人信息：\n",i+1); printf("学号：NO."); scanf("%d",&amp;student[i].num); printf("姓名："); scanf("%s",student[i].name); printf("成绩："); scanf("%f",&amp;student[i].score); printf("\n"); &#125;//录入个人信息 printf("成绩录入完毕。\n\n序号 学号 姓名 成绩\n"); for(int i=0;i&lt;n;i++) &#123; printf(" %2d %d %-s %-.1f\n",i+1,student[i].num,student[i].name,student[i].score); &#125;//输出原始的数组数据 for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; while(student[i].num == student[j].num) &#123; for(int k=j;k&lt;n;k++)&#123; student[k].num = student[k+1].num; strcpy(student[k].name,student[k+1].name); student[k].score = student[k+1].score; &#125; n--; &#125; &#125; &#125; //删除有重复学号的数据（保留第一个） printf("处理后的数据如下：\n\n序号 学号 姓名 成绩\n"); for(int i=0;i&lt;n;i++) &#123; printf(" %2d %d %-s %-.1f\n",i+1,student[i].num,student[i].name,student[i].score); &#125;//输出处理后的数组数据 system("pause"); &#125;void timeclock()&#123; time_t rawtime; struct tm * timeinfo; time ( &amp;rawtime ); timeinfo = localtime ( &amp;rawtime ); printf ( "\n欢迎登陆学生信息管理系统，系统时间为: %s\n", asctime (timeinfo) ); &#125; 日常帮写了第二份12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; int n = 10; struct stu &#123; int num; char name[20]; float score; &#125;student[n]; for(int i=0;i&lt;n;i++) &#123; printf("请输入第%d名同学的学号，姓名，成绩：",i+1); scanf("%d%s%f",&amp;student[i].num,student[i].name,&amp;student[i].score); &#125; printf("成绩录入完毕。\n\n序号 学号 姓名 成绩\n"); for(int i=0;i&lt;n;i++) &#123; printf(" %2d %d %s %.1f\n",i+1,student[i].num,student[i].name,student[i].score); &#125;//按顺序输出 for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; while(student[i].num == student[j].num) &#123; for(int k=j;k&lt;n;k++)&#123; student[k].num = student[k+1].num; strcpy(student[k].name,student[k+1].name); student[k].score = student[k+1].score; &#125; n--; &#125; &#125; &#125; //删除重复学号的信息 printf("处理后的数据如下：\n\n序号 学号 姓名 成绩\n"); for(int i=0;i&lt;n;i++) &#123; printf(" %2d %d %s %.1f\n",i+1,student[i].num,student[i].name,student[i].score); &#125;//输出处理后的数据 system("pause");&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>大二</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一下 C语言大作业]]></title>
    <url>%2F2018%2F02%2F06%2F%E5%A4%A7%E4%B8%80%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[Hi, 这篇文章是关于大一年级下学期C语言最后的大作业，年代久远，仅供参考哦~ 题目：Coursework 2016 DeadLine June 27thWrite a program that will help elementary school pupils practice math.a) The program will first ask the user for his/her ID number (including two letters &amp; 4 digits), e.g.Please input your four digit ID no: AB1234 The program should have input validation.Then the program prompts three choices:(1) Start a test(2) Check scores(3) Exit Test: the program will give 10 math problems, e.g.: 12 * 3 = 3648 + 32 = 80…56 / 28 = 2 Note:i) Pupils will answer each problem before the next one is given. ii) The problems should include addition, subtraction, multiplication and division. They are randomly generated. iii) Randomly generates numbers for problems. However, must ensure that both the problem and the result are no larger than two digits. The problem and the result should be greater than or equal to zero. The divisor cannot be zero. iv) After ten problems are finished, record the time used by the student to do the ten problems. v) Gives a score to each student. Saves this student’s ID, his/her score and the time used into a file named ‘record.txt’. vi) Print the following information on the screen:Prob. | Correct Answ. | Ur Answ c) Check scores: Searches the file ‘record.txt’ and lists all the historical scores for this student, e.g.: Your previous records are:AB1234 80 150 secondsAB1234 50 182 secondsAB1234 90 98 seconds You will be marked based on your program’s:(1) Correctiveness(2) Readability(3) Robustness(4) Conciseness 代码：注意当年我在大作业里用了goto，但后来我得知goto会影响健壮性，会扣分的，所以建议不要用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;ctype.h&gt;#include &lt;string.h&gt; main()&#123; char ID[7],option[2],symbol[10],convert[3],answer[10][3]; int n,i,a[10],b[10],result[10],score=0,grade,timeduation; time_t start, end; FILE *data; void check(char[]); do&#123; printf("Please input your four digit ID (e.g.AB1234): "); scanf("%s",ID); &#125;while(!(ID[6]=='\0'&amp;&amp;isalpha(ID[0])&amp;&amp;isalpha(ID[1])&amp;&amp;isdigit(ID[2])&amp;&amp;isdigit(ID[3])&amp;&amp;isdigit(ID[4])&amp;&amp;isdigit(ID[5])));//to inspect whether the user type in the correct ID choice://use goto function to return as a loop printf("\nPlease type in the corresponding number to continue.\n(1) Start a test\n(2) Check scores\n(3) Exit\n"); scanf("%s",option); if(option[1]!='\0'||isdigit(option[0])==0) &#123; printf("Wrong Input!"); goto choice; &#125;//to inspect whether user type in the correct number switch(option[0])//use ASCII to get the correspoding funtion &#123; case 49:getchar(); printf("---------------------------------------\n"); //start a test srand((unsigned)time(NULL)); time(&amp;start); for(i=0;i&lt;10;i++) &#123; n=rand()%4; do&#123; a[i]=rand()%100; b[i]=rand()%100; switch(n)&#123; case 0:symbol[i] = '+'; result[i] = a[i] + b[i]; break; case 1:symbol[i] = '-'; result[i] = a[i] - b[i]; break; case 2:symbol[i] = '*'; result[i] = a[i] * b[i]; break; case 3:symbol[i] = '/'; result[i] = a[i] / b[i]; &#125; &#125;while(result[i] &gt; 99 || result[i] &lt; 0 || n==3 &amp;&amp; a[i] % b[i] != 0); printf("%2d %c %2d = ", a[i], symbol[i], b[i]); itoa(result[i], convert, 10); gets(answer[i]); if (!strcmp(convert, answer[i])) &#123; score += 10; &#125; &#125; time(&amp;end); printf("---------------------------------------\nBravo! You have got %d score(s) in %ld seconds!\n",score,end-start); printf("Prob. | Correct Answ. | Ur Answ\n"); for(i=0;i&lt;10;i++) printf("(%-2d) %-2d %c %-2d = %-3d %s\n",i+1,a[i],symbol[i],b[i],result[i],answer[i]); data = fopen("record.txt", "a+"); //save the information into a file fprintf(data,"%s %d %d\n",ID,score,end-start); fclose(data); goto choice;//return to the option menu break; case 50:check(ID); goto choice;//return to the option menu break; case 51:printf("Thanks for testing! This program is about to quit.\n");//quit the program break; default:printf("Wrong Input! "); goto choice; &#125; system("pause");&#125;void check(char ID[])&#123; FILE *file; int getgrade,gettime,j=0; char getid[6]; file=fopen("record.txt","r"); if(file==NULL) printf("You have never done the test before, so there is no record."); fscanf(file,"%s %d %d",getid,&amp;getgrade,&amp;gettime); printf("Your previous records are:\n");//print the previous grades while(!feof(file)) &#123; if(strncmp(ID,getid,6)==0) &#123; printf("%s %d %d \n\n",ID,getgrade,gettime); j=1; &#125; fscanf(file,"%s %d %d",getid,&amp;getgrade,&amp;gettime); &#125; if(j==0) printf("Sorry, there is no previou grade.\n"); fclose(file);&#125; 后来又随便帮别人写了一份差不多的，也放上来吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; //This is a program that will help elementary school pupils practice math. int main()&#123; char fid[10],ID[10],symbol[10],convert[3],answer[10][3]; int j=0,i,op,n,a[10],b[10],result[10],score=0,grade,timeduation; FILE *data; time_t tstart, tend; do&#123; printf("Please input your four digit ID number such as AB1234: "); scanf("%s",ID); if(!(ID[6]=='\0'&amp;&amp;isalpha(ID[0])&amp;&amp;isalpha(ID[1])&amp;&amp;isdigit(ID[2])&amp;&amp;isdigit(ID[3])&amp;&amp;isdigit(ID[4])&amp;&amp;isdigit(ID[5]))) printf("Sorry, invalid ID. "); &#125;while(!(ID[6]=='\0'&amp;&amp;isalpha(ID[0])&amp;&amp;isalpha(ID[1])&amp;&amp;isdigit(ID[2])&amp;&amp;isdigit(ID[3])&amp;&amp;isdigit(ID[4])&amp;&amp;isdigit(ID[5])));//To check the ID invalidation choose: printf("\nPlease type in the number to continue.\n(1) Start a test\n(2) Check scores\n(3) Exit\n"); scanf("%d",&amp;op); switch(op)//let user to choose what function they want &#123; case 1: getchar(); printf("\n"); srand((unsigned)time(NULL)); time(&amp;tstart); for(i=0;i&lt;10;i++)//to start the test &#123; n=rand()%4; do&#123; a[i]=rand()%100; b[i]=rand()%100; switch(n)&#123; case 0:symbol[i] = '+'; result[i] = a[i] + b[i]; break; case 1:symbol[i] = '-'; result[i] = a[i] - b[i]; break; case 2:symbol[i] = '*'; result[i] = a[i] * b[i]; break; case 3:symbol[i] = '/'; result[i] = a[i] / b[i]; &#125; &#125;while(result[i] &gt; 99 || result[i] &lt; 0 || n==3 &amp;&amp; a[i] % b[i] != 0); printf("%2d %c %2d = ", a[i], symbol[i], b[i]); itoa(result[i], convert, 10); gets(answer[i]);//gather the user's answers if (!strcmp(convert, answer[i])) &#123; score += 10; &#125; &#125; time(&amp;tend);//time ends printf("\nYou have got %d score(s) in %ld seconds!\n",score,tend-tstart); printf("Prob. | Correct Answ. | Ur Answ\n"); //print the test information for(i=0;i&lt;10;i++) &#123; printf("(%2d) %2d %c %2d = %3d %s\n",i+1,a[i],symbol[i],b[i],result[i],answer[i]); &#125; data = fopen("record.txt", "a+"); fprintf(data,"%s %3d %3ld\n",ID,score,tend-tstart); fclose(data); goto choose; break; case 2: data=fopen("record.txt","r"); if(data==NULL) &#123; printf("You have never done the test before."); goto choose; &#125; fscanf(data,"%s %d %d",fid,&amp;grade,&amp;timeduation);//scan the user's information printf("Your previous records are:\n"); while(!feof(data)) &#123; if(strncmp(ID,fid,6)==0)//check the user's name &#123; printf("%s %d %d \n\n",fid,grade,timeduation); j=1; &#125; fscanf(data,"%s %d %d",fid,&amp;grade,&amp;timeduation); &#125; if(j==0) &#123; printf("Sorry, there is no previous record.\n"); &#125; fclose(data); goto choose; break; case 3: printf("It's about to quit! \n"); break; //quit default: printf("Wrong Number! "); goto choose; &#125; return 0;&#125; 附录：我们那年的注意事项截止日期是6月27日，迟交每日扣10%，最多扣至50%。至期末考试关闭提交系统 源代码为CPP文件,且已通过TC3编译,没有任何编译错误源文件以完整学号作为文件名，CPP作为扩展名，不得压缩将原文件作为附件以bupt.edu.cn邮箱发送至cw@wss.buptsem.net。邮件主题为完整学号提交后自行到课程网站确认提交结果文件名和邮件主题，不能是全角数字不要重复提交，每重复提交一次，扣减10%]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大一</tag>
        <tag>C语言</tag>
        <tag>Coursework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一下 C语言作业合集(EX01-EX11)]]></title>
    <url>%2F2018%2F02%2F05%2F%E5%A4%A7%E4%B8%80%E4%B8%8BC%E8%AF%AD%E8%A8%80%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Hi, 由于文件存放年代久远，且我在当时学习过程中可能有改动，仅供参考。 EX01 Programming Environment and Basic Input/Output1.Write a program that prints “This is my first program!” on the screen.(a)Save this program onto your own disk with the name of e2-1a;(b)Run this program without opening Turbo C;(c)Modify this program to print “This is my second program!”, then save it as e2-1b. Please do not overwrite the first program.12345678#include &lt;stdio.h&gt;int main ()&#123; printf("This is my first program!\n\n\n\n"); getchar(); return 0;&#125; 12345678#include &lt;stdio.h&gt;int main ()&#123; printf("This is my second program!\n\n\n\n"); getchar(); return 0;&#125; 2.Write a program that prints the number 1 to 4 on the same line. Write the program using the following methods:(a)Using four “printf” statements.(b)Using one “printf” statement with no conversion specifier (i.e. no ‘%’).(c)Using one “printf” statement with four conversion specifiers123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("1 "); printf("2 "); printf("3 "); printf("4 \n");// the first four statements are as the teacher asked. printf("1 2 3 4\n");//the second statement is for "using one printf". int a=1,b=2,c=3,d=4; printf("%d %d %d %d \n",a,b,c,d);//the last statement is for conversion specifier. system ("pause");&#125; 3．(a) Write a program that calculates and displays the number of minutes in 15 days. (b) Write a program that calculates and displays how many hours 180 minutes equal to. (c) (Optional) How about 174 minutes?1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int a, minutes; printf("Please input the number of days from 0-15 \n"); scanf("%d",&amp;a); minutes = a * 24 * 60 ; printf("the minutes is %d \n",minutes); getchar(); return 0; &#125; 1234567891011#include&lt;stdio.h&gt; int main()&#123; int a,hour; a = 180; hour = a / 60; printf("180 minutes equal to %d hours",hour); getchar(); return 0;&#125; 123456789101112#include&lt;stdio.h&gt; int main()&#123; int a; float hour; a = 174; hour = a / 60; printf("180 minutes equal to %f hours",hour); getchar(); return 0;&#125; EX02 Data Types and Arithmetic Operations You purchase a laptop computer for $889. The sales tax rate is 6 percent. Write and execute a C program that calculates and displays the total purchase price (net price + sales tax).12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int netprice; float salestax; netprice = 889; salestax = 889.00 * 0.06; float total; total = netprice + salestax; printf("The total purchase price is %f \n\n\n",total); system("pause");&#125; 2．Write a program that reads in the radius of a circle and prints the circle’s diameter, circumference and area. Use the value 3.14159 for “”.12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Please type the radius of the circle \n"); float radius; scanf("%f",&amp;radius); float diameter,circumference,area; diameter = 2 * radius; circumference = 2 * 3.14159 * radius; area = 3.14159 * radius * radius; printf("The diameter of the circle is %f \n",diameter); printf("The circumference of the circle is %f \n",circumference); printf("The area of the circle is %f \n",area); system("pause");&#125; 3．Write a program that reads in two numbers: an account balance and an annual interest rate expressed as a percentage. Your program should then display the new balance after a year. There are no deposits or withdraws – just the interest payment. Your program should be able to reproduce the following sample run:Interest calculation program.Starting balance? 6000Annual interest rate percentage? 4.25Balance after one year: 62551234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Balance calculation program \n"); printf("Starting balance? "); int balance; scanf("%d \n",&amp;balance); printf("Annual interest rate percentage? "); float rate; scanf("&amp;4.2f \n",rate); float addbalance; addbalance = balance + balance * rate * 0.01 ; printf("Balance after one year : %f \n",addbalance); system("pause");&#125; EX03 Selection Structure1．Write a C program that accepts a student’s numerical grade, converts the numerical grade to Passed (grade is between 60-100), Failed (grade is between 0-59), or Error (grade is less than 0 or greater than 100).12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Please type your grades!\n"); int grade; scanf("%d",&amp;grade); if ((grade &gt;= 60)&amp;&amp;(grade &lt;= 100)) printf("Pass\n"); else if ((grade &gt;= 0)&amp;&amp;(grade &lt;=59)) printf("Fail\n"); else printf("Error\n"); system("pause");&#125; 2．Write a program that asks the user to enter an integer number, then tells the user whether it is an odd or even number.123456789101112131415#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Please enter a integer number you want to test\n"); int num,tester; scanf("%d",&amp;num); tester = num % 2; if (tester == 0) printf("Even\n"); else printf("Odd\n"); system("pause");&#125; 3．Write a program that reads in three integers and then determines and prints the largest in the group.12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int a,b,c,max; printf("Please enter three integers to be determined \n "); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); max = a; if (max &lt;=b) max = b; if (max &lt;=c) max = c; printf("max = %d \n",max); system("pause");&#125; EX04 ‘Switch’ Statement and Simple “While” Repetition Statement Write a program that reads three integers an abbreviated date (for example: 26 12 94) and that will print the date in full; for example: 26th December 1994. The day should be followed by an appropriate suffix, ‘st’, ‘nd’, ‘rd’ or ‘th’. Use at least one switch statement.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Please type in 3 integers to be converted, for example:26 12 94 \n"); int day,month,year; scanf("%d%d%d",&amp;day,&amp;month,&amp;year); switch(day) &#123; case 1: printf("1st "); break; case 2: printf("2nd "); break; case 3: printf("3rd "); break; case 11: printf("11st "); break; case 12: printf("12nd "); break; case 13: printf("13rd "); break; case 21: printf("21st "); break; case 22: printf("22nd "); break; case 23: printf("23rd "); break; case 31: printf("31st "); break; default: printf("%dth ",day); &#125; switch(month) &#123; case 1: printf("January "); break; case 2: printf("February "); break; case 3: printf("March "); break; case 4: printf("April "); break; case 5: printf("May "); break; case 6: printf("June "); break; case 7: printf("July "); break; case 8: printf("August "); break; case 9: printf("September "); break; case 10: printf("October "); break; case 11: printf("November "); break; case 12: printf("December "); break; &#125; if(year&gt;=0 &amp;&amp; year&lt;=16) printf("20%d",year); else printf("19%d",year); system("pause");&#125; 2．Write a C program that uses a while loop to calculate and print the sum of the even integers from 2 to 30.1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i=2, sum=0; while(i&lt;=30) &#123; sum = sum + i; i = i + 2; &#125; printf("The Sum from 0 to 30 is %d \n",sum); system("pause");&#125; A large chemical company pays its sales staff on a commission basis. They receive £200 per week plus 9% of their gross sales for that week. For example, someone who sells £5000 of chemicals in one week will earn £200 plus 9% of £5000, a total of £650. Develop a C program that will input each salesperson’s sales for the previous week, and print out their salary. Process one person’s figures at a time. Enter sales in pounds (-1 to end): 5000.00 Salary is: 650.00 Enter sales in pounds (-1 to end): 00.00 Salary is: 200.00 Enter sales in pounds (-1 to end): 1088.89 Salary is: 298.00 Enter sales in pounds (-1 to end): -1 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; #define CUTOFF -1 float sales,salary; sales = 0; while (sales &gt; CUTOFF) &#123; printf("Please type in your gross sales for this week in pounds (-1 to end):"); scanf("%f",&amp;sales); salary = 200 + sales * 0.09 ; if(sales&gt;CUTOFF) printf("Salary is %6.2f \n",salary); &#125; system("pause");&#125; Optional： A mail order company sells five different products whose retail prices are shown in the following table:Product Number Retail Price (in pounds) 1 2.98 2 4.50 3 9.98 4 4.49 5 6.87Write a C program that reads in a series of pairs of numbers as follows: (1). Product number (2). Quantity sold for one dayYour program should use a switch statement to help determine the retail price for each product, and should use a sentinel-controlled loop to calculate the total retail value of all products sold in a given week (7days).123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int numday,number,quantity; float total; numday = 1; while(numday&lt;=7) &#123; printf("Please type in the product number and the quantity sold for day %d ",numday); scanf("%d%d",&amp;number,&amp;quantity); numday = numday + 1; switch(number) &#123; case 1: total = total + 2.98 * quantity; break; case 2: total = total + 4.50 * quantity; break; case 3: total = total + 9.98 * quantity; break; case 4: total = total + 4.49 * quantity; break; case 5: total = total + 6.87 * quantity; break; default: printf("Error!\n"); &#125; &#125; printf("The total retail value of all products sold in this week is %6.2f \n",total); system("pause");&#125; EX05 For and Do…while Repetition Statements Write a program which uses a do/while loop to print out the first 10 powers of 2 other than 0 (ie. it prints out the values of 2^1, 2^2, …, 2^10). Use a for loop to do the same. 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i = 1; int j = 1; do//This is the first loop for DO/WHILE repetiton. &#123; j = 2 * j ; i++; printf("%d ",j); &#125;while(i&lt;=10); printf("\n");//This is to turn to the new line. for(int i=1,j=1 ; i&lt;=10;i++)//This is the second loop for FOR repetiton. &#123; j = 2 * j ; printf("%d ",j); &#125; system("pause");&#125; The constant can be calculated by the infinite series: Pi = 4 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 +.... Write a C program that uses a do/while loop to calculate using the series. The program should ask the user how many terms in the series should be used. Thus if the user enters ‘3’, then the program should calculate Pi as being 4 - 4/3 + 4/5. 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int term; int i = 1, j = 1; float Pi = 0; float k; printf("Please type in how mant terms in the series should be used."); scanf("%d",&amp;term); do &#123; k=(float)4/(2*i-1)*j*1.00; Pi=Pi+k; j=j*(-1); i++; &#125; while(i&lt;=term); printf("%f",Pi); system("pause");&#125; Write a program that prints the following diamond shape. You may use printf statements that print either a single asterisk (*) or a single blank. Maximize your use of repetition (with nested for statements) and minimize the number of printf statements.编辑器阵亡，详情见题目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n=5,t=1,h=10; while(t&lt;=n) &#123; int i=1; while(i&lt;h+t) &#123; if(i&lt;=h-t) &#123; printf(" "); &#125; else if(i&gt;h-t&amp;&amp;i&lt;h+t) &#123; printf("*"); &#125; i++; &#125; printf("\n"); t++; &#125; t=4;h=10; while(t&gt;0) &#123; int i=1; while(i&lt;h+t) &#123; if(i&lt;=h-t) &#123; printf(" "); &#125; else if(i&gt;h-t&amp;&amp;i&lt;h+t) &#123; printf("*"); &#125; i++; &#125; printf("\n"); t--; &#125; system("pause");&#125; Write a program to print a table as follows: 11= 121= 2 22= 431= 3 32= 6 33= 9….91= 9 92=18 93=27 94=36 95=45 96=54 97=63 98=72 9*9=811234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i=1,j=1; for(i=1;j&lt;=9;i++) &#123; for(j=1;j&lt;=i;j++) &#123; printf("%d*%d=%d ",i,j,i*j); &#125; printf("\n"); &#125; system("pause");&#125; EX06 Simple Functions1.Write a C program that reads several numbers and uses the function round_to_nearest to round each of these numbers to the nearest integer. The program should print both the original number and the rounded number.123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int round_to_nearest(float);int main()&#123; float num_a;int num_b; num_a=1.0; while(num_a != 0) &#123; printf("please type in the number you want to round,and enter 0 to quit "); scanf("%f",&amp;num_a); if (num_a==0) printf("This program is about to close,please press any key to quit \n"); else &#123; num_b = round_to_nearest(num_a); printf("the original number is %f ,and the rounded number is %d \n",num_a,num_b); &#125; &#125; system("pause"); &#125;int round_to_nearest(float num_a)//Method two&#123; return (int) (num_a + 0.5);&#125;/*int round_to_nearest(float num_a)//Method One&#123; int num,num_b; num=(int)num_a; if (num-num_a&gt;0.5 || num-num_a&lt;-0.5) num_b=num+1; else num_b=num; return num_b;&#125;*/ 2.Write a program that reads three pairs of numbers and adds the larger of the first pair, the larger of the second pair and the larger of the third pair. Use a function to return the larger of each pair.12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;float larger_number(float,float);int main()&#123; float num1,num2,larger,total=0; int a=1; while (a&lt;=3) &#123; printf("Please type in a pair of numbers "); scanf("%f%f",&amp;num1,&amp;num2); larger=larger_number(num1,num2); total=total+larger; printf("The larger one in this pair of numbers is %f\n",larger); a++; &#125; printf("The total of three pairs of numbers is %f \n",total); system("pause");&#125;float larger_number(float num1,float num2)&#123; float larger; if(num1&gt;num2) larger=num1; else larger=num2; return larger;&#125; A car park charges a £2.00 minimum fee to park for up to 3 hours, and an additional £0.50 for each hour or part hour in excess of three hours. The maximum charge for any given 24-hour period is £10.00. Assume that no car parks for more than 24 hours at a time. Write a C program that will calculate and print the parking charges for each of 3 customers who parked their car in the car park yesterday. The program should accept as input the number of hours that each customer has parked, and output the results in a neat tabular form, along with the total receipts from the three customers: Car Hours Charge1 1.5 2.002 4.0 2.503 24.0 10.00TOTAL 29.5 14.50 The program should use the function calculate_charges to determine the charge for each customer. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;float calculate_charges(float);int main()&#123; float hour1,hour2,hour3,charge1,charge2,charge3,total_hours=0,total_charges=0; printf("Please type in three car's parking hours (from 0 to 24) \n"); scanf("%f%f%f",&amp;hour1,&amp;hour2,&amp;hour3); charge1=calculate_charges(hour1); charge2=calculate_charges(hour2); charge3=calculate_charges(hour3); printf("Car Hours Charge\n"); printf("1%10.1f%10.2f\n",hour1,charge1); printf("2%10.1f%10.2f\n",hour2,charge2); printf("3%10.1f%10.2f\n",hour3,charge3); total_hours=hour1+hour2+hour3; total_charges=charge1+charge2+charge3; printf("TOTAL%7.2f%9.2f\n",total_hours,total_charges); system("pause");&#125; float calculate_charges(float hour)&#123; float charge; if(hour&gt;0&amp;&amp;hour&lt;=3) charge=2; else if(hour&gt;3&amp;&amp;hour&lt;=19) charge= 2.0+0.5*(hour-3); else if(hour&gt;19&amp;&amp;hour&lt;=24) charge=10; else printf("Unvalid value of \"hour\" \n"); return charge;&#125; EX07 More Functions Write a program that uses sentinel-controlled repetition to take an integer as input, and passes it to a function even which uses the modulus operator to determine if the integer is even. The function even should return 1 if the integer is even, and 0 if it is not. The program should take the value returned by the function even and use it to print out a message announcing whether or not the integer was even. 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int even(int);int main()&#123; int num; printf("Please input an integer: (Crtl+Z or -1 to stop)\n"); num=1; while(scanf("%d", &amp;num)!=EOF) &#123; if(even(num)==1) printf("%d is an even number \n",num); else if(even(num)==0) printf("Sorry, %d is not an even number,try again!\n",num); &#125; system("pause");&#125;int even(int num)&#123; return (num+1)%2;&#125; Write a C program that uses the function integerPower1(base, exponent) to return the value of: base^exponent so that, for example, integerPower1(3, 4) gives the value 3 3 3 * 3. Assume that exponent is a positive, non-zero integer, and base is an integer. The function should use a for loop, and make no calls to any math library functions. 123456789101112131415161718int integerPower1(int,int);#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int base,exponent,integerPower1(int,int); printf("Please type in the base and exponent:\n"); scanf("%d%d",&amp;base,&amp;exponent); printf("The result is %d\n",integerPower1(base,exponent)); system("pause");&#125; int integerPower1(int base,int exponent)&#123; int ans=1; for(int i=1;base&gt;0&amp;&amp;exponent&gt;0&amp;&amp;i&lt;=exponent;i++) ans=ans*base; return ans;&#125; Write a C program that uses the recursive function integerPower2(base, exponent) to return the value of: base^exponent so that, for example, integerPower2(3, 4) gives the value 3 3 3 * 3. Assume that exponent is a positive, non-zero integer, and base is an integer. The function should make no calls to any math library functions.(Hint: the recursive step will use the relationship: base^exponent = base . base^exponent - 1 and the base case will be when exponent is 1 since : base1 = base.) 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int base, exponent, integerPower2(int, int); printf("Please input base and exponent:\n"); scanf("%d %d", &amp;base, &amp;exponent); printf("Result is %d\n", integerPower2(base,exponent)); system("pause");&#125;int integerPower2(int m, int n) &#123; if (n==1) &#123; return m; &#125; else &#123; return m * integerPower2(m, n - 1); &#125; &#125; EX08 Arrays1.Write a program that reads ten numbers supplied by the user into a single subscripted array, and then prints out the average of them.123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int numbers[10],sum=0; float average=0; for(int i =0;i&lt;10;i++) &#123; printf("Please type in an interger:\n"); scanf("%d",&amp;numbers[i]); &#125; for (int i=0;i&lt;10;i++) &#123;average=average+numbers[i];&#125; printf("Average is %f\n",average/10); system("pause");&#125; Write a program that reads ten numbers supplied by the user into a 2 by 5 array, and then prints out the maximum and minimum values held in:(a) each row (2 rows)(b) the whole array12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int numbers[2][5],max1,min1,max2,min2,maxall,minall; for(int i=0;i&lt;2;i++) &#123; for(int j=0;j&lt;5;j++) &#123; printf("Please type in the integer:"); scanf("%d",&amp;numbers[i][j]); &#125; printf("\n");&#125; for(int i=0;i&lt;2;i++) &#123; for(int j=0;j&lt;5;j++) &#123; printf("%d",numbers[i][j]); &#125; printf("\n");&#125; max1=min1=numbers[0][0]; for(int j=0;j&lt;5;j++) &#123; max1=max1&gt;numbers[0][j]? max1:numbers[0][j]; min1=min1&lt;numbers[0][j]? min1:numbers[0][j]; &#125; max2=min2=numbers[1][0]; for(int j=0;j&lt;5;j++) &#123; max2=max2&gt;numbers[1][j]? max2:numbers[1][j]; min2=min2&lt;numbers[1][j]? min2:numbers[1][j]; &#125; maxall=max1&gt;max2? max1:max2; minall=min1&lt;min2? min1:min2; printf("The maximum in row 1 is %d\n", max1); printf("The minimum in row i is %d\n", min1); printf("The maximum in row 2 is %d\n", max2); printf("The minimum in row 2 is %d\n", min2); printf("The maximum is %d\n", maxall); printf("The minimum is %d\n", minall); system("pause");&#125; 3．Use a single-subscripted array to solve the following problem. Read in 20 numbers, each of which is between 10 and 100, inclusive. As each number is read, print it only if it is not a duplicate of a number already read. Prepare for the “worst case” in which all 20 numbers are different. Use the smallest possible array to solve this problem.1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i=0,duplicate=0,a[20]; do&#123; printf("Please type an interger between 10 and 100 inclusively, or it will not be printed \n"); scanf("%d",&amp;a[i]); if(a[i]&gt;=10&amp;&amp;a[i]&lt;=100) &#123; i++; continue; &#125; for(int j=0;j&lt;i;j++) if(a[i]==a[j]) &#123; duplicate=1;break; &#125; else continue; if(duplicate==0) &#123;printf("%d\n",a[i]); &#125; else duplicate=0;i++; &#125;while(i&lt;20); system("pause");&#125; EX09 More Arrays1.Write a program that enters 5 names of towns and their respective distance (an integer) from London in miles. The program will print of the names of the towns that are less than 100 miles from London. Use arrays and character strings to implement your program.1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; main()&#123; int distance[5]; char town[5][20]; int i=0; for(i=0;i&lt;5;i++) &#123; printf("Please type in the name of town:\n");// gets(town[i]); scanf("%s",town[i]); printf("Please type in its distance to London:\n"); scanf("%d",&amp;distance[i]); &#125; for(i=0;i&lt;5;i++) &#123; if(distance[i]&lt;100) printf("The distance from %s to London is less than 100 miles.\n",town[i]); &#125; system("pause");&#125; Write a program that prompts the user to type in four character strings, places these in an array of strings, and then prints out: (e.g. I am Peter Pan) (i) The four strings in reverse order. (e.g. Pan Peter am I) (ii) The four strings in the original order, but with each string backwards. (e.g. I ma reteP naP) (iii) The four strings in reverse order with each string backwards. (e.g. naP reteP ma I) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; main()&#123; char string[4][20]; printf("Please type in 4 strings.\n"); scanf("%s %s %s %s",string[0],string[1],string[2],string[3]); for(int i=3;i&gt;=0;i--) &#123; printf("%s ",string[i]);&#125; printf("\n "); for(int i=0;i&lt;4;i++) &#123; int j; for(j=0;string[i][j]!='\0';j++); for(j=j-1;j&gt;=0;j--) printf("%c",string[i][j]); printf(" "); &#125; printf("\n"); for(int i=3;i&gt;=0;i--) &#123; int j; for(j=0;string[i][j]!='\0';j++); for(j=j-1;j&gt;=0;j--) printf("%c",string[i][j]); printf(" "); &#125; printf("\n"); system("pause");&#125; /*for(int i=3;i&gt;=0;i--) &#123; for(int j=4;j&gt;=0;j--) &#123; if(string[i][j]!='\0') printf("%c",string[i][j]); &#125; printf(" "); &#125; printf("\n ");*/ EX10 Pointers Write a program that reads 5 integers into an array, and then uses four different methods of accessing the members of an array to print them out in reverse order. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; int number[5],*NPtr; NPtr=number; printf("Please type in 5 integers:"); for(int i=0;i&lt;5;i++) &#123; scanf("%d",&amp;number[i]); &#125; printf("\n"); printf("METHOD ONE\n"); for(int i=4;i&gt;=0;i--) &#123; printf("%d ",number[i]); &#125; printf("\n"); printf("METHOD TWO\n"); for(int i=4;i&gt;=0;i--) &#123; printf("%d ",NPtr[i]); &#125; printf("\n"); printf("METHOD THREE\n"); for(int i=4;i&gt;=0;i--) &#123; printf("%d ",*(number+i)); &#125; printf("\n"); printf("METHOD FOUR\n"); for(int i=4;i&gt;=0;i--) &#123; printf("%d ",*(NPtr+i)); &#125; printf("\n"); system("pause");&#125; Write a program that reads 8 floats into an array and then prints out the second, fourth, sixth and eighth members of the array, and the sum of the first, third, fifth and seventh, using pointers to access the members of the array. 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main() &#123; float f[8],*fPtr,total=0; fPtr=f; printf("Please type in 8 floats:"); for(int i=0;i&lt;8;i++) &#123; scanf("%f",&amp;f[i]); &#125; printf("The second, fourth, sixth and eighth members of the array are as followed:\n"); for(int i=1;i&lt;8;i+=2) &#123; printf("%f ",*(fPtr+i)); &#125; printf("\n"); for(int i=0;i&lt;8;i+=2) &#123; total=total+*(fPtr+i); &#125; printf("and the sum of the first, third, fifth and seventh is: %f \n",total); system("pause");&#125; Write a program that use a SINGLE FUNCTION （用一个函数）to find and return simultaneously both the lowest and highest values in an array of type int. Suppose the size of the array is 6. 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void SingleFunction(int *,int *);int main() &#123; int num[6],i; printf("Please type in 6 numbers: \n"); for(i=0;i&lt;6;i++) &#123; scanf("%d",&amp;num[i]); &#125; SingleFunction(num,num); system("pause");&#125;void SingleFunction(int *max,int *min)&#123; int maxnum,minnum; maxnum=*max; minnum=*min; for(int i=0;i&lt;6;i++) &#123; maxnum=maxnum &gt;= *(max+i) ? maxnum : *(max+i); minnum=minnum &lt;= *(min+i) ? minnum : *(min+i); &#125; printf("The max is %d, and the min is %d\n",maxnum,minnum);&#125; EX11 Files Write a program that enters the name and the annual salary of 5 employees from the keyboard, calculates the monthly salary of each employee assuming that tax is deducted at a flat rate of 20%. The program prints the name, the annual salary and the monthly payment (net) of each employee in a file. The program adds an employee’s number to each employee before printing the names and values:No. Employee’s Name Annual salary Monthly payment after tax12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; float annualsalary[5],monthlysalary[5]; char employee[5][20]; FILE *fptr; if((fptr=fopen("salary.txt","w"))==NULL) printf("Error in opening the file \n"); else &#123; for(int i=0;i&lt;5;i++) &#123; printf("Please type in employee's name and annual salary:\n"); scanf("%s%f",&amp;employee[i],&amp;annualsalary[i]);&#125; &#125; fprintf(fptr,"No. Employee's Name Annual salary Monthly payment after tax\n"); for(int i=0;i&lt;5;i++) &#123; monthlysalary[i]=annualsalary[i]/12*0.8; fprintf(fptr," %-4d %-10s %13.3f%25.3f\n",i+1,employee[i],annualsalary[i],monthlysalary[i]); &#125; fclose(fptr); printf("OK. The program has printed the name, the annual salary and the monthly payment of each employee in a file named salary.txt \n"); system("pause");&#125; 2．Write a program that builds a file with information for 20 towns. Each line in the file contains name of a town followed by the distance of the town from London in miles (an integer).123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int distance[20]; char town[20][20]; FILE *fp; if((fp=fopen("town.txt","w"))==NULL) printf("Error in opening the file \n"); else &#123; for(int i=0;i&lt;20;i++) &#123; printf("Please type in No.%2d town's name and its distance from London:\n",i+1); scanf("%s %d",&amp;town[i],&amp;distance[i]); &#125; fprintf(fp,"No. Town's Name Distance from London \n"); for(int i=0;i&lt;20;i++) &#123; fprintf(fp,"%2d %11s %20d \n",i+1,town[i],distance[i]); &#125; &#125; fclose(fp); printf("OK. The program has built a file named town.txt with information for 20 towns. \n"); system("pause");&#125; 3．Write a program reads the file created by the above program (in Question 2) and prints the names of the towns that are less than 100 miles from London to ANOTHER file.1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int distance[20],a; char town[20][20]; FILE *input,*output; output=fopen("townanother.txt","w"); if((input=fopen("town.txt","r"))==NULL) printf("Error in opening the file \n"); else &#123; fseek(input, 41, SEEK_SET); fprintf(output, "No. Town's Name Distance from London\n"); for(int i = 0; i &lt; 20; i++) &#123; fscanf(input, "%2d %11s %20d \n", &amp;a, &amp;town[i], &amp;distance[i]); if(distance[i] &lt; 100) &#123; fprintf(output, "%2d %11s %20d \n", i + 1, town[i], distance[i]); &#125; &#125; printf("OK. It has printed the names of the towns that are less than 100 miles from London to another file.\n"); &#125; fclose(input); fclose(output); system("pause");&#125; 好啦，以上是2016年C语言课程的所有练习题，大作业的代码咱们下次再见~]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>大一</tag>
        <tag>C语言</tag>
        <tag>Coursework</tag>
      </tags>
  </entry>
</search>
